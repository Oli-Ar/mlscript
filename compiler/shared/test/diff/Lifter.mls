:NewParser
:ParseOnly

class A(x) {
  class B(y) {
    fun getX = x
    fun getB1 = B1(y)
    class C(z) {
      fun inc() = x + 1
      fun getY = y
      fun getA = A(z)
      fun getB(w) = B(w)
      fun getC = new C(inc())
      fun getSelf = this
    }
  }
  class B1(y) {
    fun getX = x
    fun getY = y
    fun getB = new B(y)
    fun getB1 = new B1(y)
  }
  fun getB = new B(x)
  fun getB2(y) = B1(y)
  fun getB3(z) = getB2(z)
  fun getA = A(x)
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{|→|#fun| |getX| |#=| |x|↵|#fun| |getB1| |#=| |B1|(|y|)|↵|#class| |C|(|z|)| |{|→|#fun| |inc|(||)| |#=| |x| |+| |1|↵|#fun| |getY| |#=| |y|↵|#fun| |getA| |#=| |A|(|z|)|↵|#fun| |getB|(|w|)| |#=| |B|(|w|)|↵|#fun| |getC| |#=| |#new| |C|(|inc|(||)|)|↵|#fun| |getSelf| |#=| |this|←|↵|}|←|↵|}|↵|#class| |B1|(|y|)| |{|→|#fun| |getX| |#=| |x|↵|#fun| |getY| |#=| |y|↵|#fun| |getB| |#=| |#new| |B|(|y|)|↵|#fun| |getB1| |#=| |#new| |B1|(|y|)|←|↵|}|↵|#fun| |getB| |#=| |#new| |B|(|x|)|↵|#fun| |getB2|(|y|)| |#=| |B1|(|y|)|↵|#fun| |getB3|(|z|)| |#=| |getB2|(|z|)|↵|#fun| |getA| |#=| |A|(|x|)|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {fun getX = x; fun getB1 = B1 (y,); class C(z,) {fun inc =  => + (x,) (1,); fun getY = y; fun getA = A (z,); fun getB = w, => B (w,); fun getC = new C(inc (),) {}; fun getSelf = this}}; class B1(y,) {fun getX = x; fun getY = y; fun getB = new B(y,) {}; fun getB1 = new B1(y,) {}}; fun getB = new B(x,) {}; fun getB2 = y, => B1 (y,); fun getB3 = z, => getB2 (z,); fun getA = A (x,)}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuTypeDef(class, B, (), Tup(_: Var(y)), (), TypingUnit(NuFunDef(None, getX, [], Var(x)), NuFunDef(None, getB1, [], App(Var(B1), Tup(_: Var(y)))), NuTypeDef(class, C, (), Tup(_: Var(z)), (), TypingUnit(NuFunDef(None, inc, [], Lam(Tup(), App(App(Var(+), Tup(_: Var(x))), Tup(_: IntLit(1))))), NuFunDef(None, getY, [], Var(y)), NuFunDef(None, getA, [], App(Var(A), Tup(_: Var(z)))), NuFunDef(None, getB, [], Lam(Tup(_: Var(w)), App(Var(B), Tup(_: Var(w))))), NuFunDef(None, getC, [], New(Some((TypeName(C),inc (),)), TypingUnit(List()))), NuFunDef(None, getSelf, [], Var(this)))))), NuTypeDef(class, B1, (), Tup(_: Var(y)), (), TypingUnit(NuFunDef(None, getX, [], Var(x)), NuFunDef(None, getY, [], Var(y)), NuFunDef(None, getB, [], New(Some((TypeName(B),y,)), TypingUnit(List()))), NuFunDef(None, getB1, [], New(Some((TypeName(B1),y,)), TypingUnit(List()))))), NuFunDef(None, getB, [], New(Some((TypeName(B),x,)), TypingUnit(List()))), NuFunDef(None, getB2, [], Lam(Tup(_: Var(y)), App(Var(B1), Tup(_: Var(y))))), NuFunDef(None, getB3, [], Lam(Tup(_: Var(z)), App(Var(getB2), Tup(_: Var(z))))), NuFunDef(None, getA, [], App(Var(A), Tup(_: Var(x)))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B$C(#par$A$B, z,) {
//│     fun inc =  => + ((((this).par$A$B).par$A).x,) (1,)
//│     fun getY = ((this).par$A$B).y
//│     fun getA = A ((this).z,)
//│     fun getB = w, => A$B (((this).par$A$B).par$A, w,)
//│     fun getC = new A$B$C((this).par$A$B, (this).inc (),) {}
//│     fun getSelf = this
//│   }
//│   class A$B(#par$A, y,) {
//│     fun getX = ((this).par$A).x
//│     fun getB1 = A$B1 ((this).par$A, (this).y,)
//│   }
//│   class A$B1(#par$A, y,) {
//│     fun getX = ((this).par$A).x
//│     fun getY = (this).y
//│     fun getB = new A$B((this).par$A, (this).y,) {}
//│     fun getB1 = new A$B1((this).par$A, (this).y,) {}
//│   }
//│   class A(x,) {
//│     fun getB = new A$B(this, (this).x,) {}
//│     fun getB2 = y, => A$B1 (this, y,)
//│     fun getB3 = z, => (this).getB2 (z,)
//│     fun getA = A ((this).x,)
//│   }
//│ }

class A(x) {
  class B(y) {
    class C(z) {
      fun sum = x + y + z
    }
  }
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{|→|#class| |C|(|z|)| |{|→|#fun| |sum| |#=| |x| |+| |y| |+| |z|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {class C(z,) {fun sum = + (+ (x,) (y,),) (z,)}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuTypeDef(class, B, (), Tup(_: Var(y)), (), TypingUnit(NuTypeDef(class, C, (), Tup(_: Var(z)), (), TypingUnit(NuFunDef(None, sum, [], App(App(Var(+), Tup(_: App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), Tup(_: Var(z)))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B$C(#par$A$B, z,) {fun sum = + (+ ((((this).par$A$B).par$A).x,) (y,),) (z,)}
//│   class A$B(#par$A, y,) {}
//│   class A(x,) {}
//│ }


class A(x) {
  class B{
    fun foo = 1
    fun bar = 11
  }
  fun getB = new B{
    fun foo = 2
    fun bar = 12
  }
  fun bar = 13
}
class C: A{
  fun getB = new B{
    fun foo = 3
    fun bar = 14
  }
  fun bar = 15
}
new C{
  fun getB = new B{
    fun foo = 4
    fun bar = 16
  }
  fun bar = 17
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|{|→|#fun| |foo| |#=| |1|↵|#fun| |bar| |#=| |11|←|↵|}|↵|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |2|↵|#fun| |bar| |#=| |12|←|↵|}|↵|#fun| |bar| |#=| |13|←|↵|}|↵|#class| |C|#:| |A|{|→|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |3|↵|#fun| |bar| |#=| |14|←|↵|}|↵|#fun| |bar| |#=| |15|←|↵|}|↵|#new| |C|{|→|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |4|↵|#fun| |bar| |#=| |16|←|↵|}|↵|#fun| |bar| |#=| |17|←|↵|}|
//│ Parsed: {class A(x,) {class B() {fun foo = 1; fun bar = 11}; fun getB = new B() {fun foo = 2; fun bar = 12}; fun bar = 13}; class C(): A {fun getB = new B() {fun foo = 3; fun bar = 14}; fun bar = 15}; new C() {fun getB = new B() {fun foo = 4; fun bar = 16}; fun bar = 17}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuTypeDef(class, B, (), Tup(), (), TypingUnit(NuFunDef(None, foo, [], IntLit(1)), NuFunDef(None, bar, [], IntLit(11)))), NuFunDef(None, getB, [], New(Some((TypeName(B),)), TypingUnit(List(fun foo = 2, fun bar = 12)))), NuFunDef(None, bar, [], IntLit(13)))), NuTypeDef(class, C, (), Tup(), (Var(A)), TypingUnit(NuFunDef(None, getB, [], New(Some((TypeName(B),)), TypingUnit(List(fun foo = 3, fun bar = 14)))), NuFunDef(None, bar, [], IntLit(15)))), New(Some((TypeName(C),)), TypingUnit(List(fun getB = new B() {fun foo = 4; fun bar = 16}, fun bar = 17))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B$_1(#par$A,): A$B ((this).par$A,) {fun foo = 2; fun bar = 12}
//│   class A$B(#par$A,) {fun foo = 1; fun bar = 11}
//│   class A(x,) {fun getB = new A$B$_1(this,) {}; fun bar = 13}
//│   class C$B$_2(#par$C,): A$B ((this).par$C,) {fun foo = 3; fun bar = 14}
//│   class C(): A {fun getB = new C$B$_2(this,) {}; fun bar = 15}
//│   class C$_3$B$_4(#par$C$_3,): A$B ((this).par$C$_3,) {fun foo = 4; fun bar = 16}
//│   class C$_3(): C () {fun getB = new C$_3$B$_4(this,) {}; fun bar = 17}
//│   Code(List(new C$_3() {}))
//│ }



class Parent<T, U, V>(x) { 
  fun foo(x: Int): T = x+1
  class Inner<W>(y: Int){
    fun bar(z: U) = foo(y)
    fun boo(z: W) = z
  }
}
//│ |#class| |Parent|‹|T|,| |U|,| |V|›|(|x|)| |{| |→|#fun| |foo|(|x|#:| |Int|)|#:| |T| |#=| |x|+|1|↵|#class| |Inner|‹|W|›|(|y|#:| |Int|)|{|→|#fun| |bar|(|z|#:| |U|)| |#=| |foo|(|y|)|↵|#fun| |boo|(|z|#:| |W|)| |#=| |z|←|↵|}|←|↵|}|
//│ Parsed: {class Parent[T, U, V](x,) {fun foo = x: Int, => + (x,) (1,) : TypeName(T); class Inner[W](y: Int,) {fun bar = z: U, => foo (y,); fun boo = z: W, => z}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Parent, (TypeName(T), TypeName(U), TypeName(V)), Tup(_: Var(x)), (), TypingUnit(NuFunDef(None, foo, [], Lam(Tup(x: Var(Int)), Asc(App(App(Var(+), Tup(_: Var(x))), Tup(_: IntLit(1))), TypeName(T)))), NuTypeDef(class, Inner, (TypeName(W)), Tup(y: Var(Int)), (), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(z: Var(U)), App(Var(foo), Tup(_: Var(y))))), NuFunDef(None, boo, [], Lam(Tup(z: Var(W)), Var(z))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Parent$Inner[W,U](#par$Parent, y: Int,) {
//│     fun bar = z: U, => ((this).par$Parent).foo ((this).y,)
//│     fun boo = z: W, => z
//│   }
//│   class Parent[T,U,V](x,) {fun foo = x: Int, => + (x,) (1,) : TypeName(T)}
//│ }


class B<T> {}
class C {}
class D(y: Int) {}
class A<T, U>(x: Int): {a1: Int} & B<T> & D(x){
  fun getA() = new C{
    fun foo(x: T) = x
  }
}
//│ |#class| |B|‹|T|›| |{||}|↵|#class| |C| |{||}|↵|#class| |D|(|y|#:| |Int|)| |{||}|↵|#class| |A|‹|T|,| |U|›|(|x|#:| |Int|)|#:| |{|a1|#:| |Int|}| |&| |B|‹|T|›| |&| |D|(|x|)|{|→|#fun| |getA|(||)| |#=| |#new| |C|{|→|#fun| |foo|(|x|#:| |T|)| |#=| |x|←|↵|}|←|↵|}|
//│ Parsed: {class B[T]() {}; class C() {}; class D(y: Int,) {}; class A[T, U](x: Int,): & ('{' {a1: Int} '}',) (& (B‹T›,) (D (x,),),) {fun getA =  => new C() {fun foo = x: T, => x}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, B, (TypeName(T)), Tup(), (), TypingUnit()), NuTypeDef(class, C, (), Tup(), (), TypingUnit()), NuTypeDef(class, D, (), Tup(y: Var(Int)), (), TypingUnit()), NuTypeDef(class, A, (TypeName(T), TypeName(U)), Tup(x: Var(Int)), (App(App(Var(&), Tup(_: Bra(rcd = true, Rcd(Var(a1) = Var(Int))))), Tup(_: App(App(Var(&), Tup(_: TyApp(Var(B), List(TypeName(T))))), Tup(_: App(Var(D), Tup(_: Var(x)))))))), TypingUnit(NuFunDef(None, getA, [], Lam(Tup(), New(Some((TypeName(C),)), TypingUnit(List(fun foo = x: T, => x))))))))
//│ Lifted:
//│ TypingUnit {
//│   class B[T]() {}
//│   class C() {}
//│   class D(y: Int,) {}
//│   class A$C$_1[T](#par$A,): C () {fun foo = x: T, => x}
//│   trait Ano$_2(a1: Int,) {}
//│   class A[T,U](x: Int,): & (Ano$_2,) (& (B‹T›,) (D ((this).x,),),) {fun getA =  => new A$C$_1(this,) {}}
//│ }
// │ TypingUnit(NuTypeDef(class, B, (TypeName(T)), Tup(), (), TypingUnit()), NuTypeDef(class, C, (), Tup(), (), TypingUnit()), NuTypeDef(class, A, (TypeName(T), TypeName(U)), Tup(x: Var(Int)), (App(App(Var(&), Tup(_: Bra(rcd = true, Rcd(Var(a1) = Var(Int)})))), Tup(_: TyApp(Var(B), List(TypeName(T)))))), TypingUnit(NuFunDef(None, getA, [], Lam(Tup(), New(Some((TypeName(C),)), TypingUnit(List(fun foo = x: T, => x))))))))

class B<T> {}
class C {}
class D(y: Int) {}
class A<T, U>(x: Int): {a1: Int}, B<T>, D(x){
  fun getA() = new C{
    fun foo(x: T) = x
  }
}
//│ |#class| |B|‹|T|›| |{||}|↵|#class| |C| |{||}|↵|#class| |D|(|y|#:| |Int|)| |{||}|↵|#class| |A|‹|T|,| |U|›|(|x|#:| |Int|)|#:| |{|a1|#:| |Int|}|,| |B|‹|T|›|,| |D|(|x|)|{|→|#fun| |getA|(||)| |#=| |#new| |C|{|→|#fun| |foo|(|x|#:| |T|)| |#=| |x|←|↵|}|←|↵|}|
//│ Parsed: {class B[T]() {}; class C() {}; class D(y: Int,) {}; class A[T, U](x: Int,): '{' {a1: Int} '}', B‹T›, D (x,) {fun getA =  => new C() {fun foo = x: T, => x}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, B, (TypeName(T)), Tup(), (), TypingUnit()), NuTypeDef(class, C, (), Tup(), (), TypingUnit()), NuTypeDef(class, D, (), Tup(y: Var(Int)), (), TypingUnit()), NuTypeDef(class, A, (TypeName(T), TypeName(U)), Tup(x: Var(Int)), (Bra(rcd = true, Rcd(Var(a1) = Var(Int))), TyApp(Var(B), List(TypeName(T))), App(Var(D), Tup(_: Var(x)))), TypingUnit(NuFunDef(None, getA, [], Lam(Tup(), New(Some((TypeName(C),)), TypingUnit(List(fun foo = x: T, => x))))))))
//│ Lifted:
//│ TypingUnit {
//│   class B[T]() {}
//│   class C() {}
//│   class D(y: Int,) {}
//│   class A$C$_1[T](#par$A,): C () {fun foo = x: T, => x}
//│   trait Ano$_2(a1: Int,) {}
//│   class A[T,U](x: Int,): Ano$_2, B‹T›, D ((this).x,) {fun getA =  => new A$C$_1(this,) {}}
//│ }

class Child<T, U>(x): { age: T } & { name: String} {
  class Inner{
    fun foo = age
  }
  fun bar = age
}
//│ |#class| |Child|‹|T|,| |U|›|(|x|)|#:| |{| |age|#:| |T| |}| |&| |{| |name|#:| |String|}| |{|→|#class| |Inner|{|→|#fun| |foo| |#=| |age|←|↵|}|↵|#fun| |bar| |#=| |age|←|↵|}|
//│ Parsed: {class Child[T, U](x,): & ('{' {age: T} '}',) ('{' {name: String} '}',) {class Inner() {fun foo = age}; fun bar = age}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Child, (TypeName(T), TypeName(U)), Tup(_: Var(x)), (App(App(Var(&), Tup(_: Bra(rcd = true, Rcd(Var(age) = Var(T))))), Tup(_: Bra(rcd = true, Rcd(Var(name) = Var(String)))))), TypingUnit(NuTypeDef(class, Inner, (), Tup(), (), TypingUnit(NuFunDef(None, foo, [], Var(age)))), NuFunDef(None, bar, [], Var(age)))))
//│ Lifted:
//│ TypingUnit {
//│   trait Ano$_1[T](age: T,) {}
//│   trait Ano$_2(name: String,) {}
//│   class Child$Inner(#par$Child,) {fun foo = ((this).par$Child).age}
//│   class Child[T,U](x,): & (Ano$_1,) (Ano$_2,) {fun bar = (this).age}
//│ }


class A(x: Int) {
  fun getA: Int = 0
  fun getA1 = 1
}
new A(0) {
  fun getA = 3
  fun getA2 = 2
}
//│ |#class| |A|(|x|#:| |Int|)| |{|→|#fun| |getA|#:| |Int| |#=| |0|↵|#fun| |getA1| |#=| |1|←|↵|}|↵|#new| |A|(|0|)| |{|→|#fun| |getA| |#=| |3|↵|#fun| |getA2| |#=| |2|←|↵|}|
//│ Parsed: {class A(x: Int,) {fun getA = 0 : TypeName(Int); fun getA1 = 1}; new A(0,) {fun getA = 3; fun getA2 = 2}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(x: Var(Int)), (), TypingUnit(NuFunDef(None, getA, [], Asc(IntLit(0), TypeName(Int))), NuFunDef(None, getA1, [], IntLit(1)))), New(Some((TypeName(A),0,)), TypingUnit(List(fun getA = 3, fun getA2 = 2))))
//│ Lifted:
//│ TypingUnit {
//│   class A(x: Int,) {fun getA = 0 : TypeName(Int); fun getA1 = 1}
//│   class A$_1(prm$Ax: Int,): A (prm$Ax: Int,) {fun getA = 3; fun getA2 = 2}
//│   Code(List(new A$_1(0,) {}))
//│ }


class A(x) {
  class B(y) {  }
}
new A(1) {
  fun getB = new B(2){
    fun getB = new B(3)
  }
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{| |}|←|↵|}|↵|#new| |A|(|1|)| |{|→|#fun| |getB| |#=| |#new| |B|(|2|)|{|→|#fun| |getB| |#=| |#new| |B|(|3|)|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {}}; new A(1,) {fun getB = new B(2,) {fun getB = new B(3,) {}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuTypeDef(class, B, (), Tup(_: Var(y)), (), TypingUnit()))), New(Some((TypeName(A),1,)), TypingUnit(List(fun getB = new B(2,) {fun getB = new B(3,) {}}))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B(#par$A, y,) {}
//│   class A(x,) {}
//│   class A$_1$B$_2(#par$A$_1, prm$By,): A$B ((this).par$A$_1, (this).prm$By,) {fun getB = new A$B((this).par$A$_1, 3,) {}}
//│   class A$_1(prm$Ax,): A ((this).prm$Ax,) {fun getB = new A$_1$B$_2(this, 2,) {}}
//│   Code(List(new A$_1(1,) {}))
//│ }



class A {
  fun getA = 0
  fun funcA = 10
}
class B: A{
  fun getA = 1
  fun funcB = 11
}
new A
new B
fun f(x) = if x is A then 0 else 1
f(new A{
  fun getA = 2
})
new B{
  fun getA = funcB
}
//│ |#class| |A| |{|→|#fun| |getA| |#=| |0|↵|#fun| |funcA| |#=| |10|←|↵|}|↵|#class| |B|#:| |A|{|→|#fun| |getA| |#=| |1|↵|#fun| |funcB| |#=| |11|←|↵|}|↵|#new| |A|↵|#new| |B|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is| |A| |#then| |0| |#else| |1|↵|f|(|#new| |A|{|→|#fun| |getA| |#=| |2|←|↵|}|)|↵|#new| |B|{|→|#fun| |getA| |#=| |funcB|←|↵|}|
//│ Parsed: {class A() {fun getA = 0; fun funcA = 10}; class B(): A {fun getA = 1; fun funcB = 11}; new A() {}; new B() {}; fun f = x, => if (is (x,) (A,)) then 0 else 1; f (new A() {fun getA = 2},); new B() {fun getA = funcB}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit(NuFunDef(None, getA, [], IntLit(0)), NuFunDef(None, funcA, [], IntLit(10)))), NuTypeDef(class, B, (), Tup(), (Var(A)), TypingUnit(NuFunDef(None, getA, [], IntLit(1)), NuFunDef(None, funcB, [], IntLit(11)))), New(Some((TypeName(A),)), TypingUnit(List())), New(Some((TypeName(B),)), TypingUnit(List())), NuFunDef(None, f, [], Lam(Tup(_: Var(x)), If((is (x,) (A,)) then 0, Some(IntLit(1))))), App(Var(f), Tup(_: New(Some((TypeName(A),)), TypingUnit(List(fun getA = 2))))), New(Some((TypeName(B),)), TypingUnit(List(fun getA = funcB))))
//│ Lifted:
//│ TypingUnit {
//│   class A() {fun getA = 0; fun funcA = 10}
//│   class B(): A {fun getA = 1; fun funcB = 11}
//│   class A$_1(): A () {fun getA = 2}
//│   class B$_2(): B () {fun getA = (this).funcB}
//│   Code(List(new A() {}))
//│   Code(List(new B() {}))
//│   fun f = x, => if (is (x,) (A,)) then 0 else 1
//│   Code(List(f (new A$_1() {},)))
//│   Code(List(new B$_2() {}))
//│ }


class A{
  class B{
    fun funB = 1
    fun foo = 100
  }
  class C: B{
    fun funC = 2
    fun foo = 1000
  }
  class D{
    fun funD = 3
    fun foo = 10000    
    class E: C{
      fun funE = 4
      fun foo = 100000
    }
    class F: E{
      fun funF = 5
      fun foo = 1000000
    }
  }
}
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |funB| |#=| |1|↵|#fun| |foo| |#=| |100|←|↵|}|↵|#class| |C|#:| |B|{|→|#fun| |funC| |#=| |2|↵|#fun| |foo| |#=| |1000|←|↵|}|↵|#class| |D|{|→|#fun| |funD| |#=| |3|↵|#fun| |foo| |#=| |10000| |↵|#class| |E|#:| |C|{|→|#fun| |funE| |#=| |4|↵|#fun| |foo| |#=| |100000|←|↵|}|↵|#class| |F|#:| |E|{|→|#fun| |funF| |#=| |5|↵|#fun| |foo| |#=| |1000000|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A() {class B() {fun funB = 1; fun foo = 100}; class C(): B {fun funC = 2; fun foo = 1000}; class D() {fun funD = 3; fun foo = 10000; class E(): C {fun funE = 4; fun foo = 100000}; class F(): E {fun funF = 5; fun foo = 1000000}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit(NuTypeDef(class, B, (), Tup(), (), TypingUnit(NuFunDef(None, funB, [], IntLit(1)), NuFunDef(None, foo, [], IntLit(100)))), NuTypeDef(class, C, (), Tup(), (Var(B)), TypingUnit(NuFunDef(None, funC, [], IntLit(2)), NuFunDef(None, foo, [], IntLit(1000)))), NuTypeDef(class, D, (), Tup(), (), TypingUnit(NuFunDef(None, funD, [], IntLit(3)), NuFunDef(None, foo, [], IntLit(10000)), NuTypeDef(class, E, (), Tup(), (Var(C)), TypingUnit(NuFunDef(None, funE, [], IntLit(4)), NuFunDef(None, foo, [], IntLit(100000)))), NuTypeDef(class, F, (), Tup(), (Var(E)), TypingUnit(NuFunDef(None, funF, [], IntLit(5)), NuFunDef(None, foo, [], IntLit(1000000)))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B(#par$A,) {fun funB = 1; fun foo = 100}
//│   class A$C(#par$A,): A$B {fun funC = 2; fun foo = 1000}
//│   class A$D$E(#par$A$D,): A$C {fun funE = 4; fun foo = 100000}
//│   class A$D$F(#par$A$D,): A$D$E {fun funF = 5; fun foo = 1000000}
//│   class A$D(#par$A,) {fun funD = 3; fun foo = 10000}
//│   class A() {}
//│ }


class A{
  class B{
    fun funB = 1
    fun foo = 100
  }
  class C: B{
    fun funC = 2
    fun foo = 1000
    fun getB = new B
  }
  class D{
    fun funD = 3
    fun foo = 10000    
    class E: C{
      fun funE = 4
      fun foo = 100000
      fun getD = new D
    }
    class F: E{
      fun funF = 5
      fun foo = 1000000
      fun getE = new E{
        fun foo = 0
      }
    }
  }
}
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |funB| |#=| |1|↵|#fun| |foo| |#=| |100|←|↵|}|↵|#class| |C|#:| |B|{|→|#fun| |funC| |#=| |2|↵|#fun| |foo| |#=| |1000|↵|#fun| |getB| |#=| |#new| |B|←|↵|}|↵|#class| |D|{|→|#fun| |funD| |#=| |3|↵|#fun| |foo| |#=| |10000| |↵|#class| |E|#:| |C|{|→|#fun| |funE| |#=| |4|↵|#fun| |foo| |#=| |100000|↵|#fun| |getD| |#=| |#new| |D|←|↵|}|↵|#class| |F|#:| |E|{|→|#fun| |funF| |#=| |5|↵|#fun| |foo| |#=| |1000000|↵|#fun| |getE| |#=| |#new| |E|{|→|#fun| |foo| |#=| |0|←|↵|}|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A() {class B() {fun funB = 1; fun foo = 100}; class C(): B {fun funC = 2; fun foo = 1000; fun getB = new B() {}}; class D() {fun funD = 3; fun foo = 10000; class E(): C {fun funE = 4; fun foo = 100000; fun getD = new D() {}}; class F(): E {fun funF = 5; fun foo = 1000000; fun getE = new E() {fun foo = 0}}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit(NuTypeDef(class, B, (), Tup(), (), TypingUnit(NuFunDef(None, funB, [], IntLit(1)), NuFunDef(None, foo, [], IntLit(100)))), NuTypeDef(class, C, (), Tup(), (Var(B)), TypingUnit(NuFunDef(None, funC, [], IntLit(2)), NuFunDef(None, foo, [], IntLit(1000)), NuFunDef(None, getB, [], New(Some((TypeName(B),)), TypingUnit(List()))))), NuTypeDef(class, D, (), Tup(), (), TypingUnit(NuFunDef(None, funD, [], IntLit(3)), NuFunDef(None, foo, [], IntLit(10000)), NuTypeDef(class, E, (), Tup(), (Var(C)), TypingUnit(NuFunDef(None, funE, [], IntLit(4)), NuFunDef(None, foo, [], IntLit(100000)), NuFunDef(None, getD, [], New(Some((TypeName(D),)), TypingUnit(List()))))), NuTypeDef(class, F, (), Tup(), (Var(E)), TypingUnit(NuFunDef(None, funF, [], IntLit(5)), NuFunDef(None, foo, [], IntLit(1000000)), NuFunDef(None, getE, [], New(Some((TypeName(E),)), TypingUnit(List(fun foo = 0)))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$B(#par$A,) {fun funB = 1; fun foo = 100}
//│   class A$C(#par$A,): A$B {
//│     fun funC = 2
//│     fun foo = 1000
//│     fun getB = new A$B((this).par$A,) {}
//│   }
//│   class A$D$E(#par$A$D,): A$C {
//│     fun funE = 4
//│     fun foo = 100000
//│     fun getD = new A$D(((this).par$A$D).par$A,) {}
//│   }
//│   class A$D$F$E$_1(#par$A$D$F,): A$D$E (((this).par$A$D$F).par$A$D,) {fun foo = 0}
//│   class A$D$F(#par$A$D,): A$D$E {
//│     fun funF = 5
//│     fun foo = 1000000
//│     fun getE = new A$D$F$E$_1(this,) {}
//│   }
//│   class A$D(#par$A,) {fun funD = 3; fun foo = 10000}
//│   class A() {}
//│ }


class A{
  class B{
    fun foo = 1
  }
  fun bar = new B
}
new A
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |foo| |#=| |1|←|↵|}|↵|#fun| |bar| |#=| |#new| |B|←|↵|}|↵|#new| |A|
//│ Parsed: {class A() {class B() {fun foo = 1}; fun bar = new B() {}}; new A() {}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit(NuTypeDef(class, B, (), Tup(), (), TypingUnit(NuFunDef(None, foo, [], IntLit(1)))), NuFunDef(None, bar, [], New(Some((TypeName(B),)), TypingUnit(List()))))), New(Some((TypeName(A),)), TypingUnit(List())))
//│ Lifted:
//│ TypingUnit {
//│   class A$B(#par$A,) {fun foo = 1}
//│   class A() {fun bar = new A$B(this,) {}}
//│   Code(List(new A() {}))
//│ }


class A(x) {
  fun foo = 0
  fun bar = x
}
let x = new A{
  fun foo = 1
  fun newFun = 2
  fun bar = new A(foo){
    fun foo = bar + 1
    fun bar2 = newFun + 1
  }
}
//│ |#class| |A|(|x|)| |{|→|#fun| |foo| |#=| |0|↵|#fun| |bar| |#=| |x|←|↵|}|↵|#let| |x| |#=| |#new| |A|{|→|#fun| |foo| |#=| |1|↵|#fun| |newFun| |#=| |2|↵|#fun| |bar| |#=| |#new| |A|(|foo|)|{|→|#fun| |foo| |#=| |bar| |+| |1|↵|#fun| |bar2| |#=| |newFun| |+| |1|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {fun foo = 0; fun bar = x}; let x = new A() {fun foo = 1; fun newFun = 2; fun bar = new A(foo,) {fun foo = + (bar,) (1,); fun bar2 = + (newFun,) (1,)}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuFunDef(None, foo, [], IntLit(0)), NuFunDef(None, bar, [], Var(x)))), NuFunDef(Some(false), x, [], New(Some((TypeName(A),)), TypingUnit(List(fun foo = 1, fun newFun = 2, fun bar = new A(foo,) {fun foo = + (bar,) (1,); fun bar2 = + (newFun,) (1,)})))))
//│ Lifted:
//│ TypingUnit {
//│   class A(x,) {fun foo = 0; fun bar = (this).x}
//│   class A$_1$A$_2(#par$A$_1, prm$Ax,): A ((this).prm$Ax,) {
//│     fun foo = + ((this).bar,) (1,)
//│     fun bar2 = + (((this).par$A$_1).newFun,) (1,)
//│   }
//│   class A$_1(prm$Ax,): A ((this).prm$Ax,) {
//│     fun foo = 1
//│     fun newFun = 2
//│     fun bar = new A$_1$A$_2(this, (this).foo,) {}
//│   }
//│   let x = new A$_1() {}
//│ }

class A {}
new A{
  fun foo = 1
  fun bar = new A{
    fun foo1 = foo
    fun bar1 = new A{
      fun foo2 = foo
      fun bar2 = new A{
        fun foo3 = foo
        fun bar3 = new A{
          fun foo4 = foo
          fun bar4 = 0
        }
      }
    }
  }
}
//│ |#class| |A| |{||}|↵|#new| |A|{|→|#fun| |foo| |#=| |1|↵|#fun| |bar| |#=| |#new| |A|{|→|#fun| |foo1| |#=| |foo|↵|#fun| |bar1| |#=| |#new| |A|{|→|#fun| |foo2| |#=| |foo|↵|#fun| |bar2| |#=| |#new| |A|{|→|#fun| |foo3| |#=| |foo|↵|#fun| |bar3| |#=| |#new| |A|{|→|#fun| |foo4| |#=| |foo|↵|#fun| |bar4| |#=| |0|←|↵|}|←|↵|}|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A() {}; new A() {fun foo = 1; fun bar = new A() {fun foo1 = foo; fun bar1 = new A() {fun foo2 = foo; fun bar2 = new A() {fun foo3 = foo; fun bar3 = new A() {fun foo4 = foo; fun bar4 = 0}}}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit()), New(Some((TypeName(A),)), TypingUnit(List(fun foo = 1, fun bar = new A() {fun foo1 = foo; fun bar1 = new A() {fun foo2 = foo; fun bar2 = new A() {fun foo3 = foo; fun bar3 = new A() {fun foo4 = foo; fun bar4 = 0}}}}))))
//│ Lifted:
//│ TypingUnit {
//│   class A() {}
//│   class A$_1$A$_2$A$_3$A$_4$A$_5(#par$A$_1$A$_2$A$_3$A$_4,): A () {
//│     fun foo4 = (((((this).par$A$_1$A$_2$A$_3$A$_4).par$A$_1$A$_2$A$_3).par$A$_1$A$_2).par$A$_1).foo
//│     fun bar4 = 0
//│   }
//│   class A$_1$A$_2$A$_3$A$_4(#par$A$_1$A$_2$A$_3,): A () {
//│     fun foo3 = ((((this).par$A$_1$A$_2$A$_3).par$A$_1$A$_2).par$A$_1).foo
//│     fun bar3 = new A$_1$A$_2$A$_3$A$_4$A$_5(this,) {}
//│   }
//│   class A$_1$A$_2$A$_3(#par$A$_1$A$_2,): A () {
//│     fun foo2 = (((this).par$A$_1$A$_2).par$A$_1).foo
//│     fun bar2 = new A$_1$A$_2$A$_3$A$_4(this,) {}
//│   }
//│   class A$_1$A$_2(#par$A$_1,): A () {
//│     fun foo1 = ((this).par$A$_1).foo
//│     fun bar1 = new A$_1$A$_2$A$_3(this,) {}
//│   }
//│   class A$_1(): A () {fun foo = 1; fun bar = new A$_1$A$_2(this,) {}}
//│   Code(List(new A$_1() {}))
//│ }

