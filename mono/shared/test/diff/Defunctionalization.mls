class Foobar {
  fun foo: Int
}
class Foo(#x): Foobar {
  fun foo = x
}
class Bar(#c): Foobar {
  fun foo = c
}
fun takeFoo(f) = f.foo
let f1 = Foo(10)
let f2 = Foo(11)
takeFoo(f2)
takeFoo(Foo(12))
//│ |#class| |Foobar| |{|→|#fun| |foo|#:| |Int|←|↵|}|↵|#class| |Foo|(|##|x|)|#:| |Foobar| |{|→|#fun| |foo| |#=| |x|←|↵|}|↵|#class| |Bar|(|##|c|)|#:| |Foobar| |{|→|#fun| |foo| |#=| |c|←|↵|}|↵|#fun| |takeFoo|(|f|)| |#=| |f|.foo|↵|#let| |f1| |#=| |Foo|(|10|)|↵|#let| |f2| |#=| |Foo|(|11|)|↵|takeFoo|(|f2|)|↵|takeFoo|(|Foo|(|12|)|)|
//│ Parsed: {class Foobar() {fun foo: [] -> Int}; class Foo(#x,): Foobar {fun foo = x}; class Bar(#c,): Foobar {fun foo = c}; fun takeFoo = f, => (f).foo; let f1 = Foo (10,) in let f2 = Foo (11,) in takeFoo (f2,); takeFoo (Foo (12,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foobar, (), Tup(), (), TypingUnit(NuFunDef(foo, [], PolyType(List(),TypeName(Int))))), NuTypeDef(class, Foo, (), Tup(_: Var(x)), (Foobar), TypingUnit(NuFunDef(foo, [], Var(x)))), NuTypeDef(class, Bar, (), Tup(_: Var(c)), (Foobar), TypingUnit(NuFunDef(foo, [], Var(c)))), NuFunDef(takeFoo, [], Lam(Tup(_: Var(f)), Sel(Var(f), foo))), Let(false, f1, App(Var(Foo), Tup(_: IntLit(10))), Let(false, f2, App(Var(Foo), Tup(_: IntLit(11))), App(Var(takeFoo), Tup(_: Var(f2))))), App(Var(takeFoo), Tup(_: App(Var(Foo), Tup(_: IntLit(12))))))
//│ Monomorphized:
//│ fun takeFoo(f) =
//│   f.foo
//│ let f1 = Foo__10() in let f2 = Foo__11() in takeFoo(f2)
//│ takeFoo(Foo__12())
//│ class Foo() {
//│ }
//│ class Foo__10(): Foo() {
//│   fun foo() =
//│     10
//│ }
//│ class Foo__11(): Foo() {
//│   fun foo() =
//│     11
//│ }
//│ class Foo__12(): Foo() {
//│   fun foo() =
//│     12
//│ }

trait Fooable {
  fun foo(x: Int): Int
}
class FooA(y): Fooable {
  fun foo(x) = x + y
}
class FooB(): Fooable {
  fun foo(x) = FooA(20).foo(x)
}
fun takeFoo(#x, f) = f.foo(x)
let f1 = FooA(10)
let f2 = FooB()
f1.foo(0)
takeFoo(42, f2)
//│ |#trait| |Fooable| |{|→|#fun| |foo|(|x|#:| |Int|)|#:| |Int|←|↵|}|↵|#class| |FooA|(|y|)|#:| |Fooable| |{|→|#fun| |foo|(|x|)| |#=| |x| |+| |y|←|↵|}|↵|#class| |FooB|(||)|#:| |Fooable| |{|→|#fun| |foo|(|x|)| |#=| |FooA|(|20|)|.foo|(|x|)|←|↵|}|↵|#fun| |takeFoo|(|##|x|,| |f|)| |#=| |f|.foo|(|x|)|↵|#let| |f1| |#=| |FooA|(|10|)|↵|#let| |f2| |#=| |FooB|(||)|↵|f1|.foo|(|0|)|↵|takeFoo|(|42|,| |f2|)|
//│ Parsed: {trait Fooable(): {fun foo: [] -> Int}; class FooA(y,): Fooable {fun foo = x, => + x y}; class FooB(): Fooable {fun foo = x, => (FooA (20,)).foo (x,)}; fun takeFoo = #x, f, => (f).foo (x,); let f1 = FooA (10,) in let f2 = FooB () in (f1).foo (0,); takeFoo (42, f2,)}
//│ cannot select a non-class instance
//│ [mono] ┌ MONO MODL
//│ [mono] │ ┌───┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
//│ [mono] │ │ 1 │ TypingUnit {                                                                                                            │
//│ [mono] │ │ 2 │   trait Fooable {foo = Int}                                                                                             │
//│ [mono] │ │ 3 │   class FooA: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@617be81c {foo = x, => + x y}                 │
//│ [mono] │ │ 4 │   class FooB: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@2f81ff60 {foo = x, => (FooA (20,)).foo (x,)} │
//│ [mono] │ │ 5 │   takeFoo = #x, f, => (f).foo (x,)                                                                                      │
//│ [mono] │ │ 6 │   Code(List(let f1 = FooA (10,) in let f2 = FooB () in (f1).foo (0,)))                                                  │
//│ [mono] │ │ 7 │   Code(List(takeFoo (42, f2,)))                                                                                         │
//│ [mono] │ │ 8 │ }                                                                                                                       │
//│ [mono] │ └───┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
//│ [mono] │ ┌ MONO TDEF trait Fooable {foo = Int}
//│ [mono] │ │ ┌ LIFT trait Fooable {foo = Int}
//│ [mono] │ │ │ ┌ MONO FUNC foo = Int
//│ [mono] │ │ │ └ MONO FUNC fun foo: [] -> Int
//│ [mono] │ │ └ LIFT
//│ [mono] │ └ MONO TDEF
//│ [mono] │   ┌───┬──────────────────────┐
//│ [mono] │   │ 1 │ trait Fooable() {    │
//│ [mono] │   │ 2 │   fun foo: [] -> Int │
//│ [mono] │   │ 3 │ }                    │
//│ [mono] │   └───┴──────────────────────┘
//│ [mono] │ ┌ MONO TDEF class FooA: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@74de7f6 {foo = x, => + x y}
//│ [mono] │ │ ┌ LIFT class FooA: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@600434d9 {foo = x, => + x y}
//│ [mono] │ │ │ ┌ MONO FUNC foo = x, => + x y
//│ [mono] │ │ │ │ ┌ MONO APP + x y
//│ [mono] │ │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ │ ┌ MONO APP + x
//│ [mono] │ │ │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ │ │ ┌ MONO VAR +
//│ [mono] │ │ │ │ │ │ └ MONO VAR +
//│ [mono] │ │ │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ │ │ ┌ MONO VAR x
//│ [mono] │ │ │ │ │ │ └ MONO VAR x
//│ [mono] │ │ │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ │ │ ┌ SPEC CALL + with (x)
//│ [mono] │ │ │ │ │ │ │ Not found: +
//│ [mono] │ │ │ │ │ │ └ SPEC CALL
//│ [mono] │ │ │ │ │ └ MONO APP +(x)
//│ [mono] │ │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ │ ┌ MONO VAR y
//│ [mono] │ │ │ │ │ └ MONO VAR y
//│ [mono] │ │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ └ MONO APP (x + y)
//│ [mono] │ │ │ └ MONO FUNC
//│ [mono] │ │ │   ┌───┬──────────────┐
//│ [mono] │ │ │   │ 1 │ fun foo(x) = │
//│ [mono] │ │ │   │ 2 │   (x + y)    │
//│ [mono] │ │ │   └───┴──────────────┘
//│ [mono] │ │ └ LIFT
//│ [mono] │ └ MONO TDEF
//│ [mono] │   ┌───┬────────────────────────────┐
//│ [mono] │   │ 1 │ class FooA(y): Fooable() { │
//│ [mono] │   │ 2 │   fun foo(x) =             │
//│ [mono] │   │ 3 │     (x + y)                │
//│ [mono] │   │ 4 │ }                          │
//│ [mono] │   └───┴────────────────────────────┘
//│ [mono] │ ┌ MONO TDEF class FooB: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@5e011bcd {foo = x, => (FooA (20,)).foo (x,)}
//│ [mono] │ │ ┌ LIFT class FooB: mlscript.mono.PrettyPrinter$$$Lambda$9569/0x00000008022eee48@7e5b8592 {foo = x, => (FooA (20,)).foo (x,)}
//│ [mono] │ │ │ ┌ MONO FUNC foo = x, => (FooA (20,)).foo (x,)
//│ [mono] │ │ │ │ ┌ MONO APP (FooA (20,)).foo (x,)
//│ [mono] │ │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ │ ┌ MONO SEL (FooA (20,)).foo
//│ [mono] │ │ │ │ │ │ ┌ MONO APP FooA (20,)
//│ [mono] │ │ │ │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ │ │ │ ┌ MONO VAR FooA
//│ [mono] │ │ │ │ │ │ │ └ MONO VAR FooA
//│ [mono] │ │ │ │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ │ │ │ ┌ MONO INTLIT 20
//│ [mono] │ │ │ │ │ │ │ └ MONO INTLIT 20
//│ [mono] │ │ │ │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ │ │ │ ┌ SPEC CALL FooA with (20)
//│ [mono] │ │ │ │ │ │ │ │ ┌ SPEC CALL class FooA with (20)
//│ [mono] │ │ │ │ │ │ │ │ └ SPEC CALL mlscript.mono.debug.Debug$$$Lambda$9628/0x00000008022fd058@6a9428e2
//│ [mono] │ │ │ │ │ │ │ └ SPEC CALL
//│ [mono] │ │ │ │ │ │ └ MONO APP FooA(20)
//│ [mono] │ │ │ │ │ └ MONO SEL FooA(20).foo
//│ [mono] │ │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ │ ┌ MONO VAR x
//│ [mono] │ │ │ │ │ └ MONO VAR x
//│ [mono] │ │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ └ MONO APP FooA(20).foo(x)
//│ [mono] │ │ │ └ MONO FUNC
//│ [mono] │ │ │   ┌───┬───────────────────┐
//│ [mono] │ │ │   │ 1 │ fun foo(x) =      │
//│ [mono] │ │ │   │ 2 │   FooA(20).foo(x) │
//│ [mono] │ │ │   └───┴───────────────────┘
//│ [mono] │ │ └ LIFT
//│ [mono] │ └ MONO TDEF
//│ [mono] │   ┌───┬───────────────────────────┐
//│ [mono] │   │ 1 │ class FooB(): Fooable() { │
//│ [mono] │   │ 2 │   fun foo(x) =            │
//│ [mono] │   │ 3 │     FooA(20).foo(x)       │
//│ [mono] │   │ 4 │ }                         │
//│ [mono] │   └───┴───────────────────────────┘
//│ [mono] │ ┌ MONO FUNC takeFoo = #x, f, => (f).foo (x,)
//│ [mono] │ │ ┌ MONO APP (f).foo (x,)
//│ [mono] │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ ┌ MONO SEL (f).foo
//│ [mono] │ │ │ │ ┌ MONO VAR f
//│ [mono] │ │ │ │ └ MONO VAR f
//│ [mono] │ │ │ └ MONO SEL f.foo
//│ [mono] │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ ┌ MONO VAR x
//│ [mono] │ │ │ └ MONO VAR x
//│ [mono] │ │ │ Specializing the invocation...
//│ [mono] │ │ └ MONO APP f.foo(x)
//│ [mono] │ └ MONO FUNC
//│ [mono] │   ┌───┬──────────────────────┐
//│ [mono] │   │ 1 │ fun takeFoo(#x, f) = │
//│ [mono] │   │ 2 │   f.foo(x)           │
//│ [mono] │   └───┴──────────────────────┘
//│ [mono] │ ┌ MONO LET let f1 = FooA (10,) in let f2 = FooB () in (f1).foo (0,)
//│ [mono] │ │ ┌ MONO APP FooA (10,)
//│ [mono] │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ ┌ MONO VAR FooA
//│ [mono] │ │ │ └ MONO VAR FooA
//│ [mono] │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ ┌ MONO INTLIT 10
//│ [mono] │ │ │ └ MONO INTLIT 10
//│ [mono] │ │ │ Specializing the invocation...
//│ [mono] │ │ │ ┌ SPEC CALL FooA with (10)
//│ [mono] │ │ │ │ ┌ SPEC CALL class FooA with (10)
//│ [mono] │ │ │ │ └ SPEC CALL mlscript.mono.debug.Debug$$$Lambda$9628/0x00000008022fd058@6a9428e2
//│ [mono] │ │ │ └ SPEC CALL
//│ [mono] │ │ └ MONO APP FooA(10)
//│ [mono] │ │ ┌ INFER FooA(10)
//│ [mono] │ │ └ INFER unknown
//│ [mono] │ │ ┌ MONO LET let f2 = FooB () in (f1).foo (0,)
//│ [mono] │ │ │ ┌ MONO APP FooB ()
//│ [mono] │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ ┌ MONO VAR FooB
//│ [mono] │ │ │ │ └ MONO VAR FooB
//│ [mono] │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ ┌ SPEC CALL FooB with ()
//│ [mono] │ │ │ │ │ ┌ SPEC CALL class FooB with ()
//│ [mono] │ │ │ │ │ └ SPEC CALL mlscript.mono.debug.Debug$$$Lambda$9628/0x00000008022fd058@6a9428e2
//│ [mono] │ │ │ │ └ SPEC CALL
//│ [mono] │ │ │ └ MONO APP FooB()
//│ [mono] │ │ │ ┌ INFER FooB()
//│ [mono] │ │ │ └ INFER unknown
//│ [mono] │ │ │ ┌ MONO APP (f1).foo (0,)
//│ [mono] │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ ┌ MONO SEL (f1).foo
//│ [mono] │ │ │ │ │ ┌ MONO VAR f1
//│ [mono] │ │ │ │ │ └ MONO VAR f1
//│ [mono] │ │ │ │ └ MONO SEL f1.foo
//│ [mono] │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ ┌ MONO INTLIT 0
//│ [mono] │ │ │ │ └ MONO INTLIT 0
//│ [mono] │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ └ MONO APP f1.foo(0)
//│ [mono] │ │ └ MONO LET let f2 = FooB() in f1.foo(0)
//│ [mono] │ └ MONO LET let f1 = FooA(10) in let f2 = FooB() in f1.foo(0)
//│ [mono] │ ┌ MONO APP takeFoo (42, f2,)
//│ [mono] │ │ Monomorphizing the callee...
//│ [mono] │ │ ┌ MONO VAR takeFoo
//│ [mono] │ │ └ MONO VAR takeFoo
//│ [mono] │ │ Monomorphizing arguments...
//│ [mono] │ │ ┌ MONO INTLIT 42
//│ [mono] │ │ └ MONO INTLIT 42
//│ [mono] │ │ ┌ MONO VAR f2
//│ [mono] │ │ └ MONO VAR f2
//│ [mono] │ │ Specializing the invocation...
//│ [mono] │ │ ┌ SPEC CALL takeFoo with (42, f2)
//│ [mono] │ │ │ ┌ SPEC CALL function takeFoo with (42, f2)
//│ [mono] │ │ │ │ ┌ INFER 42
//│ [mono] │ │ │ │ └ INFER 42
//│ [mono] │ │ │ │ ┌ SPEC EXPR f.foo(x)
//│ [mono] │ │ │ │ │ in context
//│ [mono] │ │ │ │ │ { x: 42 }
//│ [mono] │ │ │ │ │ ┌ SPEC EXPR f.foo
//│ [mono] │ │ │ │ │ │ in context
//│ [mono] │ │ │ │ │ │ { x: 42 }
//│ [mono] │ │ │ │ │ │ ┌ SPEC EXPR f
//│ [mono] │ │ │ │ │ │ │ in context
//│ [mono] │ │ │ │ │ │ │ { x: 42 }
//│ [mono] │ │ │ │ │ │ └ SPEC EXPR f
//│ [mono] │ │ │ │ │ └ SPEC EXPR f.foo
//│ [mono] │ │ │ │ │ ┌ SPEC EXPR x
//│ [mono] │ │ │ │ │ │ in context
//│ [mono] │ │ │ │ │ │ { x: 42 }
//│ [mono] │ │ │ │ │ └ SPEC EXPR 42
//│ [mono] │ │ │ │ │ ┌ INFER f
//│ [mono] │ │ │ │ │ └ INFER unknown
