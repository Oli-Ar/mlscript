
fun f(x) = if x then 42 else 1337
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |#then| |42| |#else| |1337|
//│ Parsed: {fun f = x, => if (x) then 42 else 1337}
//│ Parsed:
//│ TypingUnit(NuFunDef(f, [], Lam(Tup(_: Var(x)), If(...))))
//│ Monomorphized:
//│ fun f(x) =
//│   if x then 42 else 1337

fun foo() = 42
//│ |#fun| |foo|(|)| |#=| |42|
//│ Parsed: {fun foo = undefined, => 42}
//│ Parsed:
//│ TypingUnit(NuFunDef(foo, [], Lam(Tup(_: UnitLit(true)), IntLit(42))))
//│ Monomorphized:
//│ fun foo() =
//│   42

fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ |#fun| |foo|(|x|,| |##|b|)| |#=| |#if| |b| |#then| |x| |#else| |1337|↵|#let| |a| |#=| |foo|(|42|,| |true|)|↵|#let| |b| |#=| |foo|(|23|,| |false|)|
//│ Parsed: {fun foo = x, #b, => if (b) then x else 1337; let a = foo (42, true,) in let b = foo (23, false,) in undefined}
//│ I can't infer the type of true now
//│ [mono] ┌ MONO MODL
//│ [mono] │ ┌───┬────────────────────────────────────────────────────────────────────────────────┐
//│ [mono] │ │ 1 │ TypingUnit {                                                                   │
//│ [mono] │ │ 2 │   foo = x, #b, => if (b) then x else 1337                                      │
//│ [mono] │ │ 3 │   Code(List(let a = foo (42, true,) in let b = foo (23, false,) in undefined)) │
//│ [mono] │ │ 4 │ }                                                                              │
//│ [mono] │ └───┴────────────────────────────────────────────────────────────────────────────────┘
//│ [mono] │ ┌ MONO FUNC foo = x, #b, => if (b) then x else 1337
//│ [mono] │ │ ┌ MONO TERM if (b) then x else 1337
//│ [mono] │ │ │ ┌ MONO TERM b
//│ [mono] │ │ │ └ MONO TERM b
//│ [mono] │ │ │ ┌ MONO TERM x
//│ [mono] │ │ │ └ MONO TERM x
//│ [mono] │ │ │ ┌ MONO TERM 1337
//│ [mono] │ │ │ └ MONO TERM 1337
//│ [mono] │ │ └ MONO TERM if b then x else 1337
//│ [mono] │ └ MONO FUNC
//│ [mono] │   ┌───┬─────────────────────────┐
//│ [mono] │   │ 1 │ fun foo(x, #b) =        │
//│ [mono] │   │ 2 │   if b then x else 1337 │
//│ [mono] │   └───┴─────────────────────────┘
//│ [mono] │ ┌ MONO TERM let a = foo (42, true,) in let b = foo (23, false,) in undefined
//│ [mono] │ │ ┌ MONO TERM foo (42, true,)
//│ [mono] │ │ │ ┌ MONO TERM foo
//│ [mono] │ │ │ └ MONO TERM foo
//│ [mono] │ │ │ ┌ MONO TERM 42
//│ [mono] │ │ │ └ MONO TERM 42
//│ [mono] │ │ │ ┌ MONO TERM true
//│ [mono] │ │ │ └ MONO TERM true
//│ [mono] │ │ │ ┌ SPEC CALL foo with (42, true)
//│ [mono] │ │ │ │ ┌ SPEC CALL function foo with (42, true)

let x = 42 + 1337
//│ |#let| |x| |#=| |42| |+| |1337|
//│ Parsed: {let x = + 42 1337 in undefined}
//│ Parsed:
//│ TypingUnit(Let(false, x, App(App(Var(+), IntLit(42)), IntLit(1337)), UnitLit(true)))
//│ Monomorphized:
//│ let x = (42 + 1337) in ()

class Bar(#x)
fun foo(#b) = b
let a = foo(Bar(1))
let b = foo(Bar(2))
//│ |#class| |Bar|(|##|x|)|↵|#fun| |foo|(|##|b|)| |#=| |b|↵|#let| |a| |#=| |foo|(|Bar|(|1|)|)|↵|#let| |b| |#=| |foo|(|Bar|(|2|)|)|
//│ Parsed: {class Bar(#x,) {}; fun foo = #b, => b; let a = foo (Bar (1,),) in let b = foo (Bar (2,),) in undefined}
//│ I can't infer the type of Bar__1() now
//│ [mono] ┌ MONO MODL
//│ [mono] │ ┌───┬───────────────────────────────────────────────────────────────────────────────┐
//│ [mono] │ │ 1 │ TypingUnit {                                                                  │
//│ [mono] │ │ 2 │   class Bar {}                                                                │
//│ [mono] │ │ 3 │   foo = #b, => b                                                              │
//│ [mono] │ │ 4 │   Code(List(let a = foo (Bar (1,),) in let b = foo (Bar (2,),) in undefined)) │
//│ [mono] │ │ 5 │ }                                                                             │
//│ [mono] │ └───┴───────────────────────────────────────────────────────────────────────────────┘
//│ [mono] │ ┌ MONO TDEF class Bar {}
//│ [mono] │ │ ┌ LIFT class Bar {}
//│ [mono] │ │ └ LIFT
//│ [mono] │ └ MONO TDEF
//│ [mono] │   ┌───┬─────────────────┐
//│ [mono] │   │ 1 │ class Bar(#x) { │
//│ [mono] │   │ 2 │ }               │
//│ [mono] │   └───┴─────────────────┘
//│ [mono] │ ┌ MONO FUNC foo = #b, => b
//│ [mono] │ │ ┌ MONO TERM b
//│ [mono] │ │ └ MONO TERM b
//│ [mono] │ └ MONO FUNC
//│ [mono] │   ┌───┬───────────────┐
//│ [mono] │   │ 1 │ fun foo(#b) = │
//│ [mono] │   │ 2 │   b           │
//│ [mono] │   └───┴───────────────┘
//│ [mono] │ ┌ MONO TERM let a = foo (Bar (1,),) in let b = foo (Bar (2,),) in undefined
//│ [mono] │ │ ┌ MONO TERM foo (Bar (1,),)
//│ [mono] │ │ │ ┌ MONO TERM foo
//│ [mono] │ │ │ └ MONO TERM foo
//│ [mono] │ │ │ ┌ MONO TERM Bar (1,)
//│ [mono] │ │ │ │ ┌ MONO TERM Bar
//│ [mono] │ │ │ │ └ MONO TERM Bar
//│ [mono] │ │ │ │ ┌ MONO TERM 1
//│ [mono] │ │ │ │ └ MONO TERM 1
//│ [mono] │ │ │ │ ┌ SPEC CALL Bar with (1)
//│ [mono] │ │ │ │ │ ┌ SPEC CALL class Bar with (1)
//│ [mono] │ │ │ │ │ │ ┌ SPEC CLASS class Bar
//│ [mono] │ │ │ │ │ │ │ in context
//│ [mono] │ │ │ │ │ │ │ { x: 1 }
//│ [mono] │ │ │ │ │ │ └ SPEC CLASS
//│ [mono] │ │ │ │ │ │   ┌───┬───┐
//│ [mono] │ │ │ │ │ │   │ 1 │ { │
//│ [mono] │ │ │ │ │ │   │ 2 │ } │
//│ [mono] │ │ │ │ │ │   └───┴───┘
//│ [mono] │ │ │ │ │ └ SPEC CALL Bar__1()
//│ [mono] │ │ │ │ └ SPEC CALL
//│ [mono] │ │ │ └ MONO TERM Bar__1()
//│ [mono] │ │ │ ┌ SPEC CALL foo with (Bar__1())
//│ [mono] │ │ │ │ ┌ SPEC CALL function foo with (Bar__1())

trait AnyFoo {
  fun bar(b: int): int
}
class FooPlus(#a: int): AnyFoo {
  fun bar(b: int) = a + b
}
class FooMinus(#a: int): AnyFoo {
  fun Bar(b: int) = a - b
}
fun f(x: AnyFoo) = x.bar(42)
f(FooPlus(1))
f(FooMinus(2))
//│ |#trait| |AnyFoo| |{|→|#fun| |bar|(|b|#:| |int|)|#:| |int|←|↵|}|↵|#class| |FooPlus|(|##|a|#:| |int|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|#:| |int|)| |#=| |a| |+| |b|←|↵|}|↵|#class| |FooMinus|(|##|a|#:| |int|)|#:| |AnyFoo| |{|→|#fun| |Bar|(|b|#:| |int|)| |#=| |a| |-| |b|←|↵|}|↵|#fun| |f|(|x|#:| |AnyFoo|)| |#=| |x|.|bar|(|42|)|↵|f|(|FooPlus|(|1|)|)|↵|f|(|FooMinus|(|2|)|)|
//│ Parsed: {trait AnyFoo(): {fun bar: [] -> int}; class FooPlus(#a: int,): AnyFoo {fun bar = b: int, => + a b}; class FooMinus(#a: int,): AnyFoo {fun Bar = b: int, => - a b}; fun f = x: AnyFoo, => . x (bar (42,)); f (FooPlus (1,),); f (FooMinus (2,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(trait, AnyFoo, (), Tup(), (), TypingUnit(NuFunDef(bar, [], PolyType(List(),TypeName(int))))), NuTypeDef(class, FooPlus, (), Tup(a: Var(int)), (TypeName(AnyFoo)), TypingUnit(NuFunDef(bar, [], Lam(Tup(b: Var(int)), App(App(Var(+), Var(a)), Var(b)))))), NuTypeDef(class, FooMinus, (), Tup(a: Var(int)), (TypeName(AnyFoo)), TypingUnit(NuFunDef(Bar, [], Lam(Tup(b: Var(int)), App(App(Var(-), Var(a)), Var(b)))))), NuFunDef(f, [], Lam(Tup(x: Var(AnyFoo)), App(App(Var(.), Var(x)), App(Var(bar), Tup(_: IntLit(42)))))), App(Var(f), Tup(_: App(Var(FooPlus), Tup(_: IntLit(1))))), App(Var(f), Tup(_: App(Var(FooMinus), Tup(_: IntLit(2))))))
//│ Monomorphized:
//│ fun f(AnyFoo) =
//│   x.bar(42)
//│ f(FooPlus__1())
//│ f(FooMinus__2())
//│ class FooPlus() {
//│ }
//│ class FooPlus__1(): FooPlus() {
//│   fun bar(int) =
//│     (a + b)
//│ }
//│ class FooMinus() {
//│ }
//│ class FooMinus__2(): FooMinus() {
//│   fun Bar(int) =
//│     (a - b)
//│ }

class Bar(x: int) {
  fun FooMinus(y: int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
Car().da(Bar(1337))
bar.car
//│ |#class| |Bar|(|x|#:| |int|)| |{|→|#fun| |FooMinus|(|y|#:| |int|)| |#=| |x| |+| |y|↵|#fun| |car| |#=| |foo|(|2|)|←|↵|}|↵|#class| |Car| |{|→|#fun| |da|(|b|#:| |Bar|)| |#=| |b|.|foo|(|2|)|←|↵|}|↵|#fun| |baz|(|b|#:| |Bar|)| |#=| |b|.|foo|(|2|)|↵|#let| |bar| |#=| |Bar|(|42|)|↵|baz|(|bar|)|↵|Car|(|)|.|da|(|Bar|(|1337|)|)|↵|bar|.|car|
//│ Parsed: {class Bar(x: int,) {fun FooMinus = y: int, => + x y; fun car = foo (2,)}; class Car() {fun da = b: Bar, => . b (foo (2,))}; fun baz = b: Bar, => . b (foo (2,)); let bar = Bar (42,) in baz (bar,); . (Car (undefined,)) (da (Bar (1337,),)); . bar car}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(x: Var(int)), (), TypingUnit(NuFunDef(FooMinus, [], Lam(Tup(y: Var(int)), App(App(Var(+), Var(x)), Var(y)))), NuFunDef(car, [], App(Var(foo), Tup(_: IntLit(2)))))), NuTypeDef(class, Car, (), Tup(), (), TypingUnit(NuFunDef(da, [], Lam(Tup(b: Var(Bar)), App(App(Var(.), Var(b)), App(Var(foo), Tup(_: IntLit(2)))))))), NuFunDef(baz, [], Lam(Tup(b: Var(Bar)), App(App(Var(.), Var(b)), App(Var(foo), Tup(_: IntLit(2)))))), Let(false, bar, App(Var(Bar), Tup(_: IntLit(42))), App(Var(baz), Tup(_: Var(bar)))), App(App(Var(.), App(Var(Car), Tup(_: UnitLit(true)))), App(Var(da), Tup(_: App(Var(Bar), Tup(_: IntLit(1337)))))), App(App(Var(.), Var(bar)), Var(car)))
//│ Monomorphized:
//│ fun baz(Bar) =
//│   b.foo(2)
//│ let bar = Bar(42) in baz(bar)
//│ Car().da(Bar(1337))
//│ bar.car
