
fun f(x) = if x then 42 else 1337
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |#then| |42| |#else| |1337|
//│ Parsed: {fun f = x, => if (x) then 42 else 1337}
//│ Parsed:
//│ TypingUnit(NuFunDef(f, [], Lam(Tup(_: Var(x)), If((x) then 42, Some(IntLit(1337))))))
//│ Monomorphized:
//│ fun f(x) =
//│   if x then 42 else 1337

fun foo() = 42
//│ |#fun| |foo|(||)| |#=| |42|
//│ Parsed: {fun foo =  => 42}
//│ Parsed:
//│ TypingUnit(NuFunDef(foo, [], Lam(Tup(), IntLit(42))))
//│ Monomorphized:
//│ fun foo() =
//│   42

fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ |#fun| |foo|(|x|,| |##|b|)| |#=| |#if| |b| |#then| |x| |#else| |1337|↵|#let| |a| |#=| |foo|(|42|,| |true|)|↵|#let| |b| |#=| |foo|(|23|,| |false|)|
//│ Parsed: {fun foo = x, #b, => if (b) then x else 1337; let a = foo (42, true,) in let b = foo (23, false,) in undefined}
//│ Parsed:
//│ TypingUnit(NuFunDef(foo, [], Lam(Tup(_: Var(x), _: Var(b)), If((b) then x, Some(IntLit(1337))))), Let(false, a, App(Var(foo), Tup(_: IntLit(42), _: Var(true))), Let(false, b, App(Var(foo), Tup(_: IntLit(23), _: Var(false))), UnitLit(true))))
//│ Monomorphized:
//│ fun foo(x, #b) =
//│   if b then x else 1337
//│ let a = foo__unknown(42) in let b = foo__unknown(23) in ()
//│ fun foo__unknown(x) =
//│   1337

let x = 42 + 1337
//│ |#let| |x| |#=| |42| |+| |1337|
//│ Parsed: {let x = + 42 1337 in undefined}
//│ I can't infer the type of (42 + 1337) now
//│ [mono] ┌ MONO MODL TypingUnit {Code(List(let x = + 42 1337 in undefined))}
//│ [mono] │ ┌ MONO LET let x = + 42 1337 in undefined
//│ [mono] │ │ ┌ MONO APP + 42 1337
//│ [mono] │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ ┌ MONO APP + 42
//│ [mono] │ │ │ │ Monomorphizing the callee...
//│ [mono] │ │ │ │ ┌ MONO VAR +
//│ [mono] │ │ │ │ └ MONO VAR +
//│ [mono] │ │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ │ ┌ MONO INTLIT 42
//│ [mono] │ │ │ │ └ MONO INTLIT 42
//│ [mono] │ │ │ │ Specializing the invocation...
//│ [mono] │ │ │ │ ┌ SPEC CALL + with (42)
//│ [mono] │ │ │ │ │ Not found: +
//│ [mono] │ │ │ │ └ SPEC CALL
//│ [mono] │ │ │ └ MONO APP +(42)
//│ [mono] │ │ │ Monomorphizing arguments...
//│ [mono] │ │ │ ┌ MONO INTLIT 1337
//│ [mono] │ │ │ └ MONO INTLIT 1337
//│ [mono] │ │ │ Specializing the invocation...
//│ [mono] │ │ └ MONO APP (42 + 1337)
//│ [mono] │ │ ┌ INFER (42 + 1337)

class Bar(#x)
fun foo(#b) = b
let a = foo(Bar(1))
let b = foo(Bar(2))
//│ |#class| |Bar|(|##|x|)|↵|#fun| |foo|(|##|b|)| |#=| |b|↵|#let| |a| |#=| |foo|(|Bar|(|1|)|)|↵|#let| |b| |#=| |foo|(|Bar|(|2|)|)|
//│ Parsed: {class Bar(#x,) {}; fun foo = #b, => b; let a = foo (Bar (1,),) in let b = foo (Bar (2,),) in undefined}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(_: Var(x)), (), TypingUnit()), NuFunDef(foo, [], Lam(Tup(_: Var(b)), Var(b))), Let(false, a, App(Var(foo), Tup(_: App(Var(Bar), Tup(_: IntLit(1))))), Let(false, b, App(Var(foo), Tup(_: App(Var(Bar), Tup(_: IntLit(2))))), UnitLit(true))))
//│ Monomorphized:
//│ fun foo(#b) =
//│   b
//│ let a = foo__class Bar__1() in let b = foo__class Bar__2() in ()
//│ fun foo__class Bar__1() =
//│   Bar__1()
//│ fun foo__class Bar__2() =
//│   Bar__2()
//│ class Bar() {
//│ }
//│ class Bar__1(): Bar() {
//│ }
//│ class Bar__2(): Bar() {
//│ }

trait AnyFoo {
  fun bar(b: int): int
}
class FooPlus(#a: int): AnyFoo {
  fun bar(b: int) = a + b
}
class FooMinus(#a: int): AnyFoo {
  fun Bar(b: int) = a - b
}
fun f(x: AnyFoo) = x.bar(42)
f(FooPlus(1))
f(FooMinus(2))
//│ |#trait| |AnyFoo| |{|→|#fun| |bar|(|b|#:| |int|)|#:| |int|←|↵|}|↵|#class| |FooPlus|(|##|a|#:| |int|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|#:| |int|)| |#=| |a| |+| |b|←|↵|}|↵|#class| |FooMinus|(|##|a|#:| |int|)|#:| |AnyFoo| |{|→|#fun| |Bar|(|b|#:| |int|)| |#=| |a| |-| |b|←|↵|}|↵|#fun| |f|(|x|#:| |AnyFoo|)| |#=| |x|.bar|(|42|)|↵|f|(|FooPlus|(|1|)|)|↵|f|(|FooMinus|(|2|)|)|
//│ Parsed: {trait AnyFoo(): {fun bar: [] -> int}; class FooPlus(#a: int,): AnyFoo {fun bar = b: int, => + a b}; class FooMinus(#a: int,): AnyFoo {fun Bar = b: int, => - a b}; fun f = x: AnyFoo, => (x).bar (42,); f (FooPlus (1,),); f (FooMinus (2,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(trait, AnyFoo, (), Tup(), (), TypingUnit(NuFunDef(bar, [], PolyType(List(),TypeName(int))))), NuTypeDef(class, FooPlus, (), Tup(a: Var(int)), (AnyFoo), TypingUnit(NuFunDef(bar, [], Lam(Tup(b: Var(int)), App(App(Var(+), Var(a)), Var(b)))))), NuTypeDef(class, FooMinus, (), Tup(a: Var(int)), (AnyFoo), TypingUnit(NuFunDef(Bar, [], Lam(Tup(b: Var(int)), App(App(Var(-), Var(a)), Var(b)))))), NuFunDef(f, [], Lam(Tup(x: Var(AnyFoo)), App(Sel(Var(x), bar), Tup(_: IntLit(42))))), App(Var(f), Tup(_: App(Var(FooPlus), Tup(_: IntLit(1))))), App(Var(f), Tup(_: App(Var(FooMinus), Tup(_: IntLit(2))))))
//│ Monomorphized:
//│ fun f(AnyFoo) =
//│   x.bar(42)
//│ f(FooPlus__1())
//│ f(FooMinus__2())
//│ class FooPlus() {
//│ }
//│ class FooPlus__1(): FooPlus() {
//│   fun bar(int) =
//│     (a + b)
//│ }
//│ class FooMinus() {
//│ }
//│ class FooMinus__2(): FooMinus() {
//│   fun Bar(int) =
//│     (a - b)
//│ }

class Bar(x: int) {
  fun FooMinus(y: int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
Car().da(Bar(1337))
bar.car
//│ |#class| |Bar|(|x|#:| |int|)| |{|→|#fun| |FooMinus|(|y|#:| |int|)| |#=| |x| |+| |y|↵|#fun| |car| |#=| |foo|(|2|)|←|↵|}|↵|#class| |Car| |{|→|#fun| |da|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|←|↵|}|↵|#fun| |baz|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|↵|#let| |bar| |#=| |Bar|(|42|)|↵|baz|(|bar|)|↵|Car|(||)|.da|(|Bar|(|1337|)|)|↵|bar|.car|
//│ Parsed: {class Bar(x: int,) {fun FooMinus = y: int, => + x y; fun car = foo (2,)}; class Car() {fun da = b: Bar, => (b).foo (2,)}; fun baz = b: Bar, => (b).foo (2,); let bar = Bar (42,) in baz (bar,); (Car ()).da (Bar (1337,),); (bar).car}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(x: Var(int)), (), TypingUnit(NuFunDef(FooMinus, [], Lam(Tup(y: Var(int)), App(App(Var(+), Var(x)), Var(y)))), NuFunDef(car, [], App(Var(foo), Tup(_: IntLit(2)))))), NuTypeDef(class, Car, (), Tup(), (), TypingUnit(NuFunDef(da, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))))), NuFunDef(baz, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))), Let(false, bar, App(Var(Bar), Tup(_: IntLit(42))), App(Var(baz), Tup(_: Var(bar)))), App(Sel(App(Var(Car), Tup()), da), Tup(_: App(Var(Bar), Tup(_: IntLit(1337))))), Sel(Var(bar), car))
//│ Monomorphized:
//│ fun baz(Bar) =
//│   b.foo(2)
//│ let bar = Bar(42) in baz(bar)
//│ Car().da(Bar(1337))
//│ bar.car
