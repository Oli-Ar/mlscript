
// The most primitive if expressions must work.
fun neg(#x) = 0 - x
fun abs(#x) = if x > 0 then x else neg of x
//│ |#fun| |neg|(|##|x|)| |#=| |0| |-| |x|↵|#fun| |abs|(|##|x|)| |#=| |#if| |x| |>| |0| |#then| |x| |#else| |neg| |#of| |x|
//│ Parsed: {fun neg = #x, => - 0 x; fun abs = #x, => if (> x 0) then x else neg (x,)}
//│ unimplemented 0

// UCS is not supported by the monomorphizer.
if
  true  then "true"
  false then "false"
//│ |#if|→|true| |#then| |"true"|↵|false| |#then| |"false"|
//│ Parsed: {if ‹(true) then "true"; (false) then "false"›}
//│ unsupported IfBlock

fun inc(#x) = x + 1
fun dbl(#x) = x * 2
fun app(f, x) = f(x)
class Box(value) {
  fun map(f) = Box(f(value))
  fun get = this.value
}
new Box(0) {
  fun get = this.value + 1
}
//│ |#fun| |inc|(|##|x|)| |#=| |x| |+| |1|↵|#fun| |dbl|(|##|x|)| |#=| |x| |*| |2|↵|#fun| |app|(|f|,| |x|)| |#=| |f|(|x|)|↵|#class| |Box|(|value|)| |{|→|#fun| |map|(|f|)| |#=| |Box|(|f|(|value|)|)|↵|#fun| |get| |#=| |this|.|value|←|↵|}|↵|#new| |Box|(|0|)| |{|→|#fun| |get| |#=| |this|.|value| |+| |1|←|↵|}|
//│ Parsed: {fun inc = #x, => + x 1; fun dbl = #x, => * x 2; fun app = f, x, => f (x,); class Box(value,) {fun map = f, => Box (f (value,),); fun get = . this value}; new Box(0,) {fun get = + (. this value) 1}}
//│ fun inc(#x) = ((+ x) 1)
//│ fun dbl(#x) = ((* x) 2)
//│ fun app(f, x) = (f x)
//│ (Box_0 )
//│ class Box_0 { fun map(f) = (Box (f value))
//│ fun get() = ((. this) value) }


fun pow(#n, x) =
  if n > 1 then pow(n - 1, x) * x
  else 1
//│ |#fun| |pow|(|##|n|,| |x|)| |#=|→|#if| |n| |>| |1| |#then| |pow|(|n| |-| |1|,| |x|)| |*| |x|↵|#else| |1|
//│ Parsed: {fun pow = #n, x, => {if (> n 1) then * (pow (- n 1, x,)) x else 1}}
//│ fun pow(#n, x) = if ((> n) 1) then ((* (pow ((- n) 1) x)) x) else 1

pow(0, 123)
//│ |pow|(|0|,| |123|)|
//│ Parsed: {pow (0, 123,)}
//│ (pow 0 123)


