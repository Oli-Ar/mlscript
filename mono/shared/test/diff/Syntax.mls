
// The most primitive if expressions must work.
fun neg(#x) = 0 - x
fun abs(#x) = if x > 0 then x else neg of x
//│ |#fun| |neg|(|##|x|)| |#=| |0| |-| |x|↵|#fun| |abs|(|##|x|)| |#=| |#if| |x| |>| |0| |#then| |x| |#else| |neg| |#of| |x|
//│ Parsed: {fun neg = #x, => - 0 x; fun abs = #x, => if (> x 0) then x else neg (x,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(neg, [], Lam(Tup(_: Var(x)), App(App(Var(-), IntLit(0)), Var(x)))), NuFunDef(abs, [], Lam(Tup(_: Var(x)), If((> x 0) then x, Some(App(Var(neg), Tup(_: Var(x))))))))
//│ Monomorphized:
//│ fun neg(#x) =
//│   (0 - x)
//│ fun abs(#x) =
//│   if (x > 0) then x else neg__unknown()
//│ fun neg__unknown() =
//│   (0 - x)

// UCS is not supported by the monomorphizer.
if
  true  then "true"
  false then "false"
//│ |#if|→|true| |#then| |"true"|↵|false| |#then| |"false"|←|
//│ Parsed: {if ‹(true) then "true"; (false) then "false"›}
//│ unsupported IfBlock
//│ [mono] ┌ MONO MODL
//│ [mono] │ ┌───┬─────────────────────────────────────────────────────────────┐
//│ [mono] │ │ 1 │ TypingUnit {                                                │
//│ [mono] │ │ 2 │   Code(List(if ‹(true) then "true"; (false) then "false"›)) │
//│ [mono] │ │ 3 │ }                                                           │
//│ [mono] │ └───┴─────────────────────────────────────────────────────────────┘
//│ [mono] │ ┌ MONO IF if ‹(true) then "true"; (false) then "false"›

fun inc(#x) = x + 1
fun dbl(#x) = x * 2
fun app(f, x) = f(x)
class Box(value) {
  fun map(f) = Box(f(value))
  fun get = this.value
}
new Box(0) {
  fun get = this.value + 1
}
//│ |#fun| |inc|(|##|x|)| |#=| |x| |+| |1|↵|#fun| |dbl|(|##|x|)| |#=| |x| |*| |2|↵|#fun| |app|(|f|,| |x|)| |#=| |f|(|x|)|↵|#class| |Box|(|value|)| |{|→|#fun| |map|(|f|)| |#=| |Box|(|f|(|value|)|)|↵|#fun| |get| |#=| |this|.value|←|↵|}|↵|#new| |Box|(|0|)| |{|→|#fun| |get| |#=| |this|.value| |+| |1|←|↵|}|
//│ Parsed: {fun inc = #x, => + x 1; fun dbl = #x, => * x 2; fun app = f, x, => f (x,); class Box(value,) {fun map = f, => Box (f (value,),); fun get = (this).value}; new Box(0,) {fun get = + (this).value 1}}
//│ Parsed:
//│ TypingUnit(NuFunDef(inc, [], Lam(Tup(_: Var(x)), App(App(Var(+), Var(x)), IntLit(1)))), NuFunDef(dbl, [], Lam(Tup(_: Var(x)), App(App(Var(*), Var(x)), IntLit(2)))), NuFunDef(app, [], Lam(Tup(_: Var(f), _: Var(x)), App(Var(f), Tup(_: Var(x))))), NuTypeDef(class, Box, (), Tup(_: Var(value)), (), TypingUnit(NuFunDef(map, [], Lam(Tup(_: Var(f)), App(Var(Box), Tup(_: App(Var(f), Tup(_: Var(value))))))), NuFunDef(get, [], Sel(Var(this), value)))), New(Some((TypeName(Box),0,)), TypingUnit(List(Right(fun get = + (this).value 1)))))
//│ Monomorphized:
//│ fun inc(#x) =
//│   (x + 1)
//│ fun dbl(#x) =
//│   (x * 2)
//│ fun app(f, x) =
//│   f(x)
//│ Box_0()


fun pow(#n, x) =
  if n > 1 then pow(n - 1, x) * x
  else 1
pow(0, 123)
//│ |#fun| |pow|(|##|n|,| |x|)| |#=|→|#if| |n| |>| |1| |#then| |pow|(|n| |-| |1|,| |x|)| |*| |x|↵|#else| |1|←|↵|pow|(|0|,| |123|)|
//│ Parsed: {fun pow = #n, x, => {if (> n 1) then * (pow (- n 1, x,)) x else 1}; pow (0, 123,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(pow, [], Lam(Tup(_: Var(n), _: Var(x)), Blk(If((> n 1) then * (pow (- n 1, x,)) x, Some(IntLit(1)))))), App(Var(pow), Tup(_: IntLit(0), _: IntLit(123))))
//│ Monomorphized:
//│ fun pow(#n, x) =
//│   if (n > 1) then (pow((n - 1), x) * x) else 1
//│ pow__0(123)
//│ fun pow__0(x) =
//│   1

let f = (x) => x + 1
//│ |#let| |f| |#=| |(|x|)| |=>| |x| |+| |1|
//│ Parsed: {let f = => '(' x, ')' (+ x 1) in undefined}
//│ Parsed:
//│ TypingUnit(Let(false, f, App(App(Var(=>), Bra(rcd = false, Tup(_: Var(x)))), App(App(Var(+), Var(x)), IntLit(1))), UnitLit(true)))
//│ Monomorphized:
//│ let f = Lambda_0() in ()
//│ class Lambda_0() {
//│   fun apply(x) =
//│     (x + 1)
//│ }

let f = (x, y) => x + y
//│ |#let| |f| |#=| |(|x|,| |y|)| |=>| |x| |+| |y|
//│ Parsed: {let f = => '(' x, y, ')' (+ x y) in undefined}
//│ Parsed:
//│ TypingUnit(Let(false, f, App(App(Var(=>), Bra(rcd = false, Tup(_: Var(x), _: Var(y)))), App(App(Var(+), Var(x)), Var(y))), UnitLit(true)))
//│ Monomorphized:
//│ let f = Lambda_0() in ()
//│ class Lambda_0() {
//│   fun apply(x, y) =
//│     (x + y)
//│ }
