
// The most primitive if expressions must work.
fun neg(#x) = 0 - x
fun abs(#x) = if x > 0 then x else neg of x
//│ |#fun| |neg|(|##|x|)| |#=| |0| |-| |x|↵|#fun| |abs|(|##|x|)| |#=| |#if| |x| |>| |0| |#then| |x| |#else| |neg| |#of| |x|
//│ Parsed: {fun neg = #x, => - 0 x; fun abs = #x, => if (> x 0) then x else neg (x,)}
//│ I can't infer the type of x now

// UCS is not supported by the monomorphizer.
if
  true  then "true"
  false then "false"
//│ |#if|→|true| |#then| |"true"|↵|false| |#then| |"false"|
//│ Parsed: {if ‹(true) then "true"; (false) then "false"›}
//│ unsupported IfBlock

fun inc(#x) = x + 1
fun dbl(#x) = x * 2
fun app(f, x) = f(x)
class Box(value) {
  fun map(f) = Box(f(value))
  fun get = this.value
}
new Box(0) {
  fun get = this.value + 1
}
//│ |#fun| |inc|(|##|x|)| |#=| |x| |+| |1|↵|#fun| |dbl|(|##|x|)| |#=| |x| |*| |2|↵|#fun| |app|(|f|,| |x|)| |#=| |f|(|x|)|↵|#class| |Box|(|value|)| |{|→|#fun| |map|(|f|)| |#=| |Box|(|f|(|value|)|)|↵|#fun| |get| |#=| |this|.|value|←|↵|}|↵|#new| |Box|(|0|)| |{|→|#fun| |get| |#=| |this|.|value| |+| |1|←|↵|}|
//│ Parsed: {fun inc = #x, => + x 1; fun dbl = #x, => * x 2; fun app = f, x, => f (x,); class Box(value,) {fun map = f, => Box (f (value,),); fun get = . this value}; new Box(0,) {fun get = + (. this value) 1}}
//│ Parsed:
//│ TypingUnit(NuFunDef(inc, [], Lam(Tup(_: Var(x)), App(App(Var(+), Var(x)), IntLit(1)))), NuFunDef(dbl, [], Lam(Tup(_: Var(x)), App(App(Var(*), Var(x)), IntLit(2)))), NuFunDef(app, [], Lam(Tup(_: Var(f), _: Var(x)), App(Var(f), Tup(_: Var(x))))), NuTypeDef(class, Box, (), Tup(_: Var(value)), (), TypingUnit(NuFunDef(map, [], Lam(Tup(_: Var(f)), App(Var(Box), Tup(_: App(Var(f), Tup(_: Var(value))))))), NuFunDef(get, [], App(App(Var(.), Var(this)), Var(value))))), New(Some((TypeName(Box),0,)), TypingUnit(NuFunDef(get, [], App(App(Var(+), App(App(Var(.), Var(this)), Var(value))), IntLit(1))))))
//│ Monomorphized:
//│ fun inc(#x) =
//│   (x + 1)
//│ fun dbl(#x) =
//│   (x * 2)
//│ fun app(f, x) =
//│   (f x)
//│ (Box_0 )
//│ class Box_0 {
//│   fun map(f) =
//│     (Box (f value))
//│   fun get() =
//│     this.value
//│ }


fun pow(#n, x) =
  if n > 1 then pow(n - 1, x) * x
  else 1
pow(0, 123)
//│ |#fun| |pow|(|##|n|,| |x|)| |#=|→|#if| |n| |>| |1| |#then| |pow|(|n| |-| |1|,| |x|)| |*| |x|↵|#else| |1|←|↵|pow|(|0|,| |123|)|
//│ Parsed: {fun pow = #n, x, => {if (> n 1) then * (pow (- n 1, x,)) x else 1}; pow (0, 123,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(pow, [], Lam(Tup(_: Var(n), _: Var(x)), Blk(If(...)))), App(Var(pow), Tup(_: IntLit(0), _: IntLit(123))))
//│ Monomorphized:
//│ fun pow(#n, x) =
//│   if (n > 1) then ((pow (n - 1), x) * x) else 1
//│ (pow__0 123)
//│ fun pow__0(x) =
//│   1

let f = (x) => x + 1
//│ |#let| |f| |#=| |(|x|)| |=>| |x| |+| |1|
//│ Parsed: {let f = => '(' x, ')' (+ x 1) in undefined}
//│ Parsed:
//│ TypingUnit(Let(false, f, App(App(Var(=>), Bra(rcd = false, Tup(_: Var(x)))), App(App(Var(+), Var(x)), IntLit(1))), UnitLit(true)))
//│ Monomorphized:
//│ let f = new Lambda_0 ()  in undefined
//│ class Lambda_0 {
//│   fun apply(x) =
//│     (x + 1)
//│ }

let f = (x, y) => x + y
//│ |#let| |f| |#=| |(|x|,| |y|)| |=>| |x| |+| |y|
//│ Parsed: {let f = => '(' x, y, ')' (+ x y) in undefined}
//│ Parsed:
//│ TypingUnit(Let(false, f, App(App(Var(=>), Bra(rcd = false, Tup(_: Var(x), _: Var(y)))), App(App(Var(+), Var(x)), Var(y))), UnitLit(true)))
//│ Monomorphized:
//│ let f = new Lambda_0 ()  in undefined
//│ class Lambda_0 {
//│   fun apply(x, y) =
//│     (x + y)
//│ }
