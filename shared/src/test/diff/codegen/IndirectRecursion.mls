
// * Strangely, why Y does not work (cycle check error),
// * Z type checks find thanks to recursive types...


def z: (('a -> 'b) -> (('a -> 'b) & 'c)) -> 'c
//│ z: (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = <missing implementation>

// :e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ((forall 'a, 'b, 'c. (('b -> 'c,)
//│   where
//│     'a <: 'a -> 'b -> 'c)) -> anything & (forall 'd, 'e, 'f. (('e -> 'f,)
//│   where
//│     'd <: 'd -> 'e -> 'f)) -> 'g) -> 'g
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z]


def pow1 = z (fun pow0 -> fun n -> fun x ->
    if n > 0 then pow0 (n - 1) x * x
    else 1
  )
//│ pow1: int -> (int & 'a) -> (forall 'a, 'b. (int
//│   where
//│     'b <: int -> 'a -> int))
//│     = [Function (anonymous)]

pow1 3 4
//│ res: int
//│   where
//│     'a <: int -> 4 -> int
//│    = 64


def pow pow n x =
    if n > 0 then pow (n - 1) x * x
    else 1
//│ pow: 'a -> int -> (int & 'b) -> (forall 'a, 'b. (int
//│   where
//│     'a <: int -> 'b -> int))
//│    = [Function: pow]

def pow = z pow
pow 3 4
//│ pow: int -> (int & 'a) -> (forall 'a, 'b. (int
//│   where
//│     'b <: int -> 'a -> int))
//│    = [Function (anonymous)]
//│ res: int
//│   where
//│     'a <: int -> 4 -> int
//│    = 64


def oops = z (fun f -> f)
//│ oops: anything -> nothing
//│     = [Function (anonymous)]

:re
oops 1
//│ res: nothing
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


// Now with constrained-arg-gen these work!?

:NoRecursiveTypes

// :e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ((forall 'a, 'b, 'c. (('b -> 'c,)
//│   where
//│     'a <: 'a -> 'b -> 'c)) -> anything & (forall 'd, 'e, 'f. (('e -> 'f,)
//│   where
//│     'd <: 'd -> 'e -> 'f)) -> 'g) -> 'g
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z1]

:NoCycleCheck

// // Exceeds recursion depth limit:
// :e
def z =
  (fun f -> (fun x -> f (fun v -> (x x) v)) (fun x -> f (fun v -> (x x) v)))
//│ ((forall 'a, 'b, 'c. (('b -> 'c,)
//│   where
//│     'a <: 'a -> 'b -> 'c)) -> anything & (forall 'd, 'e, 'f. (('e -> 'f,)
//│   where
//│     'd <: 'd -> 'e -> 'f)) -> 'g) -> 'g
//│   <:  z:
//│ (('a -> 'b) -> ('a -> 'b & 'c)) -> 'c
//│  = [Function: z2]

