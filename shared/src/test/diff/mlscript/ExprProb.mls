
def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│            = <missing implementation>
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│            = [Function: intToString]
//│ done: nothing -> nothing
//│     = [Function: done]



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> 'b) -> 'lhs -> 'b
//│   where
//│     'lhs <: Add[?] & {lhs: 'lhs} | 'a & ~add
//│           = [Function: eval1_stub]

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | 'a & ~add
//│           = [Function: eval1_stub1]

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ eval1_stub: forall 'eval1_stub, 'a, 'b, 'c, 'lhs, 'd, 'e, 'lhs0. 'eval1_stub
//│   where
//│     'eval1_stub :> 'a -> (1 | 'd | 0)
//│                 <: (forall 'lhs1. ('lhs1
//│   where
//│     'c <: {lhs: 'lhs1})) -> 'd
//│     'd :> 1 | 'd | 0
//│     'a :> forall 'lhs1. ('lhs1
//│   where
//│     'c <: {lhs: 'lhs1})
//│        <: lit & 'b | (add & 'c | 'e & ~add) & ~lit
//│     'c <: {lhs: 'lhs0} & {lhs: 'lhs}
//│     'lhs0 <: lit & 'b | (add & 'c | 'e & ~add) & ~lit
//│           = [Function: eval1_stub2]

eval1_stub
//│ res: 'lhs -> (0 | 1)
//│   where
//│     'lhs <: Add[?] & {lhs: 'lhs} | Lit | ~Add[?] & ~Lit
//│    = [Function: eval1_stub2]

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ eval1: ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│      = [Function: eval1]
//│ constrain calls  : 93
//│ annoying  calls  : 0
//│ subtyping calls  : 103

:ns
eval1
//│ res: forall 'a, 'val, 'b, 'c, 'lhs, 'd, 'e, 'rhs, 'f, 'g, 'rhs0, 'lhs0. forall 'eval1, 'h, 'i, 'a, 'val, 'b, 'c, 'lhs, 'd, 'e, 'rhs, 'f, 'g, 'j, 'k, 'rhs0, 'lhs0. 'eval1
//│   where
//│     'eval1 :> 'h -> 'i -> ('val | 'g | 'k)
//│            <: 'h -> 'e & 'h -> 'c
//│     'c :> 'i -> ('val | 'g | 'k)
//│        <: (forall 'lhs1. ('lhs1
//│   where
//│     'b <: {lhs: 'lhs1})) -> 'd
//│     'd :> 'val | 'g | 'k
//│        <: int
//│     'e :> 'i -> ('val | 'g | 'k)
//│        <: (forall 'rhs1. ('rhs1
//│   where
//│     'b <: {rhs: 'rhs1})) -> 'f
//│     'f :> 'val | 'g | 'k
//│        <: int
//│     'g := int
//│     'i :> (forall 'lhs1. ('lhs1
//│   where
//│     'b <: {lhs: 'lhs1})) | (forall 'rhs1. ('rhs1
//│   where
//│     'b <: {rhs: 'rhs1}))
//│        <: lit & 'a | (add & 'b | 'j & ~add) & ~lit
//│     'b <: {lhs: 'lhs0} & {rhs: 'rhs0} & {rhs: 'rhs} & {lhs: 'lhs}
//│     'rhs0 <: lit & 'a | (add & 'b | 'j & ~add) & ~lit
//│     'lhs0 <: lit & 'a | (add & 'b | 'j & ~add) & ~lit
//│     'a <: {val: 'val}
//│     'val <: int
//│     'h <: 'j -> 'k
//│     'k <: int
//│    = [Function: eval1]

:re
error: ~Add[?]
//│ res: ~Add[nothing]
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & ~Lit) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a) -> ('a & Add[?])
error: ('a) -> ('a & ~Add[?])
error: ('a & ~Add[?]) -> 'a
//│ res: 'a -> (Add[?] & 'a)
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: 'a -> ('a & ~Add[nothing])
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: ('a & ~Add[?]) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: forall 'a, 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~Lit & ~Add[?]
//│              = <missing implementation>

eval1_ty_ugly
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty_ugly is not implemented

:stats
def eval1_ty_ugly = eval1
//│ ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1]
//│ constrain calls  : 95
//│ annoying  calls  : 46
//│ subtyping calls  : 366

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: forall 'a, 'b. ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~lit & ~add
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~add & ~lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 95
//│ annoying  calls  : 46
//│ subtyping calls  : 368

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~add & ~lit | Add['b] | Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│              = [Function: eval1]
//│ constrain calls  : 18
//│ annoying  calls  : 1
//│ subtyping calls  : 196

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~Add[?] & ~Lit | Add['b] | Lit
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 18
//│ annoying  calls  : 1
//│ subtyping calls  : 978


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1[+A]
//│ eval1_ty: forall 'a. ('a -> int) -> E1['a] -> int
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> E1['a] -> int
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│   <:  eval1_ty:
//│ ('a -> int) -> E1['a] -> int
//│         = [Function: eval1]
//│ constrain calls  : 97
//│ annoying  calls  : 48
//│ subtyping calls  : 242


:stats
rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ pretty1: ('a -> string) -> 'rhs -> string
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│        = [Function: pretty1]
//│ constrain calls  : 110
//│ annoying  calls  : 0
//│ subtyping calls  : 107


:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      if ev e.lhs == 0 then prettier1 k ev e.rhs
      else if ev e.rhs == 0 then prettier1 k ev e.lhs
      else concat (prettier1 k ev e.lhs) (prettier1 k ev e.rhs)
  | _ -> k e
  }
//│ prettier1: ('a -> string) -> ('lhs -> anything & 'lhs -> int & 'rhs -> anything & 'rhs -> int) -> 'rhs0 -> string
//│   where
//│     'rhs0 <: Add[?] & {lhs: 'lhs & 'rhs0, rhs: 'rhs & 'rhs0} | Lit | 'a & ~add & ~lit
//│          = [Function: prettier1]
//│ constrain calls  : 383
//│ annoying  calls  : 0
//│ subtyping calls  : 167

:stats
rec def prettier11 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e.rhs == 0 then tmp else concat tmp (prettier11 k ev e.rhs)
  | _ -> k e
  }
//│ prettier11: ('a -> string & 'b -> string) -> ('rhs -> anything & 'rhs -> int) -> 'rhs0 -> string
//│   where
//│     'rhs0 <: Add[?] & {lhs: 'rhs1, rhs: 'rhs & 'rhs0} | Lit | 'a & ~add & ~lit
//│     'rhs1 <: Add[?] & {lhs: 'rhs1, rhs: 'rhs1} | Lit | 'b & ~add & ~lit
//│           = [Function: prettier11]
//│ constrain calls  : 240
//│ annoying  calls  : 0
//│ subtyping calls  : 231

// Doesn't make much sense, but generates very ugly type unless aggressively simplified:
:stats
rec def prettier12 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ prettier12: ('a -> string & 'b -> string & 'c -> string & 'd -> 'e & 'f -> string & 'g -> string) -> ('h -> anything & 'h -> int) -> (Add[?] & {lhs: 'rhs, rhs: 'rhs0 & 'rhs1 & 'rhs2 & 'rhs3} & 'h | Lit | 'd & ~add & ~lit) -> (string | 'e)
//│   where
//│     'rhs3 <: Add[?] & {lhs: 'rhs3, rhs: 'rhs3} | Lit | 'b & ~add & ~lit
//│     'rhs2 <: Add[?] & {lhs: 'rhs2, rhs: 'rhs2} | Lit | 'c & ~add & ~lit
//│     'rhs1 <: Add[?] & {lhs: 'rhs1, rhs: 'rhs1} | Lit | 'g & ~add & ~lit
//│     'rhs0 <: Add[?] & {lhs: 'rhs0, rhs: 'rhs0} | Lit | 'f & ~add & ~lit
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│           = [Function: prettier12]
//│ constrain calls  : 221
//│ annoying  calls  : 0
//│ subtyping calls  : 630


:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ constrain calls  : 4314
//│ annoying  calls  : 1695
//│ subtyping calls  : 15994


e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
prettier11 done (eval1 done) e1
prettier12 done (eval1 done) e1
//│ e1: Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega[+E]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ eval2: ('a -> int) -> 'rhs -> int
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | Nega[?] & {arg: 'rhs} | 'a & ~add & ~lit & ~nega
//│      = [Function: eval2]


:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ prettier2: ('a -> string) -> ('lhs -> anything & 'lhs -> int & 'rhs -> anything & 'rhs -> int) -> 'rhs0 -> string
//│   where
//│     'rhs0 <: Add[?] & {lhs: 'lhs & 'rhs0, rhs: 'rhs & 'rhs0} | Lit | Nega[?] & {arg: 'rhs0} | 'a & ~add & ~lit & ~nega
//│          = [Function: prettier2]
//│ constrain calls  : 135
//│ annoying  calls  : 0
//│ subtyping calls  : 263

:stats
rec def prettier22 k ev = prettier12 (fun x -> case x of {
  | Nega -> concat "-" (prettier22 k ev x.arg)
  | _ -> k x
  }) ev
//│ prettier22: ('a -> string) -> ('b -> anything & 'b -> int) -> 'c -> string
//│   where
//│     'b <: {lhs: 'rhs, rhs: 'rhs}
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'd & ~add & ~lit
//│     'd <: Nega[?] & {arg: 'c} | 'a & ~nega
//│     'c <: Add[?] & 'b | Lit | 'd & ~add & ~lit
//│           = [Function: prettier22]
//│ constrain calls  : 238
//│ annoying  calls  : 0
//│ subtyping calls  : 690



:stats
eval2 done e1
//│ res: int
//│    = 6
//│ constrain calls  : 280
//│ annoying  calls  : 100
//│ subtyping calls  : 328

e2 = add (lit 1) (nega e1)
//│ e2: Add[Lit & {val: 1} | Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]] with {lhs: Lit & {val: 1}, rhs: Nega[Add[Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}} | Lit & {val: 1}] with {lhs: Lit & {val: 1}, rhs: Add[Lit & {val: 2 | 3}] & {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}]}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }

// :e // FIXME (reproduced in `ADRsRepro.mls`)
:stats
eval2 done e2
//│ res: int
//│    = -5
//│ constrain calls  : 414
//│ annoying  calls  : 168
//│ subtyping calls  : 603

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega[Add[Lit & {val: 1} | Nega[Lit & {val: 1}]] with {lhs: Lit & {val: 1}, rhs: Nega[Lit & {val: 1}]}]
//│   = Nega { arg: Add { lhs: Lit { val: 1 }, rhs: Nega { arg: [Lit] } } }

// :e // FIXME (reproduced in `ADRsRepro.mls`)
:stats
eval2 done d2
//│ res: int
//│    = 0
//│ constrain calls  : 241
//│ annoying  calls  : 101
//│ subtyping calls  : 253


prettier2 done
//│ res: ('lhs -> anything & 'lhs -> int & 'rhs -> anything & 'rhs -> int) -> 'rhs0 -> string
//│   where
//│     'rhs0 <: Add[?] & {lhs: 'lhs & 'rhs0, rhs: 'rhs & 'rhs0} | Lit | Nega[?] & {arg: 'rhs0}
//│    = [Function (anonymous)]

prettier22 done
//│ res: ('a -> anything & 'a -> int) -> 'b -> string
//│   where
//│     'a <: {lhs: 'rhs, rhs: 'rhs}
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'c & ~add & ~lit
//│     'c <: Nega[?] & {arg: 'b}
//│     'b <: Add[?] & 'a | Lit | 'c & ~add & ~lit
//│    = [Function (anonymous)]

:stats
prettier2 done (eval1 done)
//│ res: 'rhs -> string
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs & 'rhs0, rhs: 'rhs & 'rhs0} | Lit | Nega[?] & {arg: 'rhs}
//│     'rhs0 <: Add[?] & {lhs: 'rhs0, rhs: 'rhs0} | Lit
//│    = [Function (anonymous)]
//│ constrain calls  : 252
//│ annoying  calls  : 0
//│ subtyping calls  : 903

prettier22 done (eval1 done)
//│ res: 'arg -> string
//│   where
//│     'arg <: Add[?] & {lhs: 'rhs, rhs: 'rhs} & 'rhs0 | Lit | 'a & ~add & ~lit
//│     'rhs0 <: Add[?] & {lhs: 'rhs0, rhs: 'rhs0} | Lit
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│     'a <: Nega[?] & {arg: 'arg}
//│    = [Function (anonymous)]

// :e // FIXME (reproduced in `ADRsRepro.mls`)
// TODO could probably merge `a` and `b` here!
:stats
prettier2 done (eval2 done)
//│ res: 'rhs -> string
//│   where
//│     'rhs <: Add[?] & {lhs: 'rhs & 'rhs0, rhs: 'rhs & 'rhs0} | Lit | Nega[?] & {arg: 'rhs}
//│     'rhs0 <: Add[?] & {lhs: 'rhs0, rhs: 'rhs0} | Lit | Nega[?] & {arg: 'rhs0}
//│    = [Function (anonymous)]
//│ constrain calls  : 299
//│ annoying  calls  : 0
//│ subtyping calls  : 1495

prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ res: string
//│    = '1-123'
//│ res: string
//│    = '-1-1'

:stats
prettier22 done (eval2 done)
prettier22 done (eval2 done) e2
prettier22 done (eval2 done) d2
//│ res: 'arg -> string
//│   where
//│     'arg <: Add[?] & {lhs: 'rhs, rhs: 'rhs} & 'rhs0 | Lit | 'a & ~add & ~lit
//│     'rhs0 <: Add[?] & {lhs: 'rhs0, rhs: 'rhs0} | Lit | Nega[?] & {arg: 'rhs0}
//│     'rhs <: Add[?] & {lhs: 'rhs, rhs: 'rhs} | Lit | 'a & ~add & ~lit
//│     'a <: Nega[?] & {arg: 'arg}
//│    = [Function (anonymous)]
//│ res: string
//│    = '1-123'
//│ res: string
//│    = '-1'
//│ constrain calls  : 4276
//│ annoying  calls  : 1776
//│ subtyping calls  : 14195




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval1 done e2
//│ ║        	^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] & {Nega#E = ?E, arg: ?arg}` does not match type `nothing`
//│ ║  l.389: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                                   ^^^^^
//│ res: error | int
//│ Runtime error:
//│   Error: non-exhaustive case expression


:e
prettier2 done eval1 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c)` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = '123'


:e
:stats
prettier2 done (eval1 done) e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Nega[?E] & {Nega#E = ?E, arg: ?arg}` does not match type `nothing`
//│ ║  l.389: 	def nega arg = Nega { arg }
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	def done x = case x of {}
//│ ║       	                  ^
//│ ╟── from field selection:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	                 ^^^^^
//│ res: error
//│ Runtime error:
//│   Error: non-exhaustive case expression
//│ constrain calls  : 2547
//│ annoying  calls  : 778
//│ subtyping calls  : 10474

:e
:stats
prettier2 done eval2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = [Function (anonymous)]
//│ constrain calls  : 217
//│ annoying  calls  : 0
//│ subtyping calls  : 749

:e
:stats
prettier2 done eval2 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = '123'
//│ constrain calls  : 224
//│ annoying  calls  : 0
//│ subtyping calls  : 749

:e
:stats
prettier2 done eval2 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = '1-123'
//│ constrain calls  : 224
//│ annoying  calls  : 0
//│ subtyping calls  : 749

:e
:stats
prettier2 done eval2 d2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 d2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = '-1-1'
//│ constrain calls  : 224
//│ annoying  calls  : 0
//│ subtyping calls  : 749

:e
:stats
prettier2 done eval1 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c)` is not an instance of type `int`
//│ ║  l.76: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.77: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.78: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.79: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.80: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.286: 	      else if ev e.rhs == 0 then prettier1 k ev e.lhs
//│ ╙──       	              ^^^^^^^^
//│ res: error
//│    = '1-123'
//│ constrain calls  : 203
//│ annoying  calls  : 0
//│ subtyping calls  : 409

