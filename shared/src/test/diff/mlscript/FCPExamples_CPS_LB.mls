:NoJS

// TODO investigate why this makes many tests fail:
:GeneralizeCurriedFunctions
:NoRecursiveTypes


// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

// Used to represent `::`
def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]`
def nil: List['a]
//│ nil: List[nothing]

def concat: string -> List[string] -> string
//│ concat: string -> List[string] -> string


// ------------ Examples ------------


// (* s  starts a sequence, cps style *)
def s k = k () nil
//│ s: (() -> List[nothing] -> 'a) -> 'a

def insert v () acu k = k () (cons v acu)
//│ insert: 'b -> () -> (forall 'c. 'c -> (forall 'c. ((() -> (forall 'b, 'c, 'a. (List['a | 'b]
//│   where
//│     'c <: List['a])) -> 'd) -> 'd
//│   where
//│     'c <: List['c])))

// (* x  inserts "x" in the acu *)
def x () = insert "x" ()
//│ x: () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List["x" | 'a]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))

// (* We call x a 'token', in the sequence. *)

// (* e  ends the sequence. It builds a token that can be inserted in another sequence or that can be printed. *)
def e () acu = insert (concat "," acu)
//│ e: () -> List[string] -> () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))


// (* Prints a token *)
def print t = t () nil (fun () -> fun r -> log (concat "," r))
//│ print: (() -> List[nothing] -> (() -> List[string] -> unit) -> 'a) -> 'a

// Added by me:
s x x (s x x e)
//│ res: (() -> (forall 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List[?]


:stats
def test8  = (s x x (s x x e) x (s x x x e) e)
//│ test8: () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))
//│ constrain calls  : 4585
//│ annoying  calls  : 942
//│ subtyping calls  : 1735

print test8


//  ===========================


// * Note: The definitions below work much better (basically seamlessly) if we don't contraint-generalize arguments:

// * These need lots of fuel...

// This fixes `test14`, but it takes close to a minute on my laptop:
// :Fuel 5000000

:e
def test14 = (s x x x x x x x x x x x x x x e)
//│ ╔══[ERROR] Subtyping constraint of the form `?a <: (forall ?b. () -> ?b) -> ?c` took too many steps and ran out of fuel (10000)
//│ ║  l.98: 	def test14 = (s x x x x x x x x x x x x x x e)
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^
//│ ╟──  + (list<> & {List#a: mut ..'a3649'})
//│ ╟──  + List['a3649']
//│ ║  l.20: 	def nil: List['a]
//│ ║        	         ^^^^^^^^
//│ ╟──  + ‹∀ 0. List['a31']›
//│ ║  l.20: 	def nil: List['a]
//│ ║        	         ^^^^^^^^
//│ ╟──  + ‹∀ 0. List['a31']›
//│ ║  l.20: 	def nil: List['a]
//│ ║        	         ^^^^^^^^
//│ ╟──  + ‹∀ 0. List['a31']›
//│ ║  l.31: 	def s k = k () nil
//│ ║        	               ^^^
//│ ╟──  + ‹∀ 0. List['a31']›
//│ ╟──  + α1094'
//│ ╟──  - {List#a: mut ..'a3646'}
//│ ╟──  - (list<> & {List#a: mut ..'a3646'})
//│ ╟──  - List['a3646']
//│ ║  l.16: 	def cons: 'a -> List['a] -> List['a]
//│ ╙──      	                ^^^^^^^^
//│ test14: error

// def test14 = (s x x x x x x x x x x x x x x e)

// def test16 = (s x x x x x x x x x x x x x x x x e)

// (* This is too much for the type-checker. *)
// def test18 = (s x x x x x x x x x x x x x x x x x x e)


// (* A function that receives a token *)
def f t = (s x x t x x e)
//│ f: (() -> (forall 'b, 'a. (List["x" | 'a]
//│   where
//│     'b <: List['a])) -> (() -> (forall 'c. 'c -> (forall 'c, 'd. ((() -> (forall 'c, 'a0. (List["x" | 'a0]
//│   where
//│     'c <: List['a0])) -> 'e) -> 'e
//│   where
//│     'c <: List['d])))) -> (() -> (forall 'c. 'c -> (forall 'c, 'd. ((() -> (forall 'c, 'a0. (List["x" | 'a0]
//│   where
//│     'c <: List['a0])) -> 'e) -> 'e
//│   where
//│     'c <: List['d])))) -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a1. (List['a1 | string]
//│   where
//│     'd <: List['a1])) -> 'f) -> 'f
//│   where
//│     'd <: List['d])))) -> 'g) -> 'g

// (* If the token is used twice, we must reveive two arguments *)
def g t1 t2 = (s x x t1 x (s x t2 x e) e)
//│ g: 'b -> (forall 'b. ('c -> 'd
//│   where
//│     'b <: () -> (forall 'e, 'a. (List["x" | 'a]
//│   where
//│     'e <: List['a])) -> (() -> (forall 'f. 'f -> (forall 'f, 'g. ((() -> (forall 'f, 'a0. (List["x" | 'a0]
//│   where
//│     'f <: List['a0])) -> 'h) -> 'h
//│   where
//│     'f <: List['g])))) -> (forall 'c. ('i
//│   where
//│     'c <: () -> (forall 'j, 'a1. (List["x" | 'a1]
//│   where
//│     'j <: List['a1])) -> (() -> (forall 'f. 'f -> (forall 'f, 'g. ((() -> (forall 'f, 'a0. (List["x" | 'a0]
//│   where
//│     'f <: List['a0])) -> 'h) -> 'h
//│   where
//│     'f <: List['g])))) -> (() -> List[string] -> () -> (forall 'g. 'g -> (forall 'g. ((() -> (forall 'g, 'a2. (List['a2 | string]
//│   where
//│     'g <: List['a2])) -> 'k) -> 'k
//│   where
//│     'g <: List['g])))) -> 'i)) -> (() -> List[string] -> () -> (forall 'g. 'g -> (forall 'g. ((() -> (forall 'g, 'a2. (List['a2 | string]
//│   where
//│     'g <: List['a2])) -> 'k) -> 'k
//│   where
//│     'g <: List['g])))) -> 'd))

// (* This does not type. It requires first-class polymorphism. *)
def h t = g t t
//│ h: (() -> (forall 'b, 'a. (List["x" | 'a]
//│   where
//│     'b <: List['a])) -> (() -> (forall 'c. 'c -> (forall 'c, 'd. ((() -> (forall 'c, 'a0. (List["x" | 'a0]
//│   where
//│     'c <: List['a0])) -> 'e) -> 'e
//│   where
//│     'c <: List['d])))) -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a1. (List['a1 | string]
//│   where
//│     'd <: List['a1])) -> 'f) -> 'f
//│   where
//│     'd <: List['d])))) -> 'd & () -> (forall 'g, 'a2. (List["x" | 'a2]
//│   where
//│     'g <: List['a2])) -> (() -> (forall 'c. 'c -> (forall 'c, 'd. ((() -> (forall 'c, 'a0. (List["x" | 'a0]
//│   where
//│     'c <: List['a0])) -> 'e) -> 'e
//│   where
//│     'c <: List['d])))) -> (forall 'h. ('i
//│   where
//│     'h <: () -> (forall 'j, 'a3. (List["x" | 'a3]
//│   where
//│     'j <: List['a3])) -> (() -> (forall 'c. 'c -> (forall 'c, 'd. ((() -> (forall 'c, 'a0. (List["x" | 'a0]
//│   where
//│     'c <: List['a0])) -> 'e) -> 'e
//│   where
//│     'c <: List['d])))) -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a1. (List['a1 | string]
//│   where
//│     'd <: List['a1])) -> 'f) -> 'f
//│   where
//│     'd <: List['d])))) -> 'i)) -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a1. (List['a1 | string]
//│   where
//│     'd <: List['a1])) -> 'f) -> 'f
//│   where
//│     'd <: List['d])))) -> 'k & 'h) -> 'k


//  ===========================

// * Now these work fine with either `:NoConstrainnedTypes` or `:NoArgGen`:

:NoConstrainnedTypes
// :NoArgGen

def s k = k () nil
def insert v () acu k = k () (cons v acu)
def x () = insert "x" ()
//│ s: (() -> List[nothing] -> 'a) -> 'a
//│ insert: 'b -> () -> (forall 'a. List['a] -> (forall 'c. (() -> List['a | 'b] -> 'c) -> 'c))
//│ x: () -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))

def test14 = (s x x x x x x x x x x x x x x e)
//│ test14: () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))

def test16 = (s x x x x x x x x x x x x x x x x e)
//│ test16: () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))

// (* This is too much for the type-checker. *)
def test18 = (s x x x x x x x x x x x x x x x x x x e)
//│ test18: () -> (forall 'b. 'b -> (forall 'b. ((() -> (forall 'b, 'a. (List['a | string]
//│   where
//│     'b <: List['a])) -> 'c) -> 'c
//│   where
//│     'b <: List['b])))


// (* A function that receives a token *)
def f t = (s x x t x x e)
//│ f: (() -> List["x"] -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> (() -> List[string] -> () -> (forall 'c. 'c -> (forall 'c. ((() -> (forall 'c, 'a0. (List['a0 | string]
//│   where
//│     'c <: List['a0])) -> 'd) -> 'd
//│   where
//│     'c <: List['c])))) -> 'e) -> 'e

// (* If the token is used twice, we must reveive two arguments *)
def g t1 t2 = (s x x t1 x (s x t2 x e) e)
//│ g: (() -> List["x"] -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> 'c -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a0. (List['a0 | string]
//│   where
//│     'd <: List['a0])) -> 'e) -> 'e
//│   where
//│     'd <: List['d])))) -> 'f) -> (() -> List["x"] -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> (() -> List[string] -> () -> (forall 'd. 'd -> (forall 'd. ((() -> (forall 'd, 'a0. (List['a0 | string]
//│   where
//│     'd <: List['a0])) -> 'e) -> 'e
//│   where
//│     'd <: List['d])))) -> 'c) -> 'f

// (* This does not type. It requires first-class polymorphism. *)
def h t = g t t
//│ h: (() -> List["x"] -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> (() -> List[string] -> () -> (forall 'c. 'c -> (forall 'c. ((() -> (forall 'c, 'a0. (List['a0 | string]
//│   where
//│     'c <: List['a0])) -> 'd) -> 'd
//│   where
//│     'c <: List['c])))) -> 'e & () -> List["x"] -> (() -> (forall 'a. List['a] -> (forall 'b. (() -> List["x" | 'a] -> 'b) -> 'b))) -> 'e -> (() -> List[string] -> () -> (forall 'c. 'c -> (forall 'c. ((() -> (forall 'c, 'a0. (List['a0 | string]
//│   where
//│     'c <: List['a0])) -> 'd) -> 'd
//│   where
//│     'c <: List['c])))) -> 'f) -> 'f

