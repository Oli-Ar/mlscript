:NoJS

:GeneralizeCurriedFunctions


// ------------ Dummy classes to represent the types in the examples ------------

class List[a]
  method Get: a
//│ Defined class List[+a]
//│ Declared List.Get: List['a] -> 'a

class ST[S, A]
  method Inv_S: S -> S
  method Cov_A: A
//│ Defined class ST[=S, +A]
//│ Declared ST.Inv_S: ST['S, ?] -> 'S -> 'S
//│ Declared ST.Cov_A: ST['S, 'A] -> 'A


// ============ Type signatures for functions used in the examples ============

def choose x y = if true then x else y
//│ choose: 'a -> (forall 'b. 'b -> ('a | 'b))

def id x = x
//│ id: 'a -> 'a

def auto (x: forall 'a. 'a -> 'a) = x x
//│ auto: (forall 'a. 'a -> 'a) -> (forall 'b, 'c. ('c
//│   where
//│     'b <: 'b -> 'c))

def app f x = f x
//│ app: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c
//│   where
//│     'a <: 'b -> 'c)))

def inc: int -> int
//│ inc: int -> int

// Used to represent `::` in the papers
def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def single: 'a -> List['a]
//│ single: 'a -> List['a]

def head: List['a] -> 'a
//│ head: List['a] -> 'a

def tail: List['a] -> List['a]
//│ tail: List['a] -> List['a]

def append: List['a] -> List['a] -> List['a]
//│ append: List['a] -> List['a] -> List['a]

def runST: (forall 's. ST['s, 'v]) -> 'v
//│ runST: (forall 's. ST['s, 'v]) -> 'v

def argST: ST['s, int]
//│ argST: ST['s, int]


// ============ Raising ML to the power of System F (2003) ============

// This used to be `'a -> (forall 'b. 'b -> 'b | 'a)`, now it's wrong!
// FreezeML A2
choose id
//│ res: 'a -> (forall 'a, 'b. 'b -> 'b | 'a)

fun (g: forall 'a. ('a -> 'a) -> ('a -> 'a)) -> fun (x: forall 'a. 'a -> 'a) -> fun a -> g a (x a)
//│ res: (forall 'a. ('a -> 'a) -> 'a -> 'a) -> (forall 'a0. 'a0 -> 'a0) -> (forall 'b. 'b -> (forall 'b, 'c, 'd, 'e, 'f. ('e
//│   where
//│     'c <: 'b -> 'd -> 'e
//│     'f <: 'b -> 'd)))

choose id succ
//│ res: int -> int

// FreezeML A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'b) -> (forall 'b, 'c, 'd. ('b | 'd
//│   where
//│     'c <: 'c -> 'd))

// nope, along with anything with it as a subterm
// i.e. unannotated auto
omega = fun x -> x x
//│ omega: 'a -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))

fun (x: forall 'a. 'a) -> x x
//│ res: anything -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))

// i.e. auto
omegad = fun (x: forall 'a. 'a -> 'a) -> x x
//│ omegad: (forall 'a. 'a -> 'a) -> (forall 'b, 'c. ('c
//│   where
//│     'b <: 'b -> 'c))

// FreezeML A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b, 'c. ('c
//│   where
//│     'b <: 'b -> 'c))

// ~ auto id (FreezeML F5, PolyML 1.1)
(fun x -> x id) auto
//│ res: 'a
//│   where
//│     'b <: (forall 'c. 'c -> 'c) -> 'a

app auto id
//│ res: 'a
//│   where
//│     'b <: (forall 'c. 'c -> 'c) -> 'a

// ------------ Sec 5.2 ------------

// Error in the paper (confirmed by Rémy via email).
:e
let f = choose id in (f auto) (f succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.130: 	let f = choose id in (f auto) (f succ)
//│ ║         	                     ^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.29: 	def auto (x: forall 'a. 'a -> 'a) = x x
//│ ║        	                    ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.29: 	def auto (x: forall 'a. 'a -> 'a) = x x
//│ ╙──      	                    ^^
//│ res: int -> int | error | 'a
//│   where
//│     'b <: 'b -> 'a

// Reproduced with an unnanotated auto:

def auto2 x = x x
//│ auto2: 'a -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))

choose id auto2
//│ res: 'a -> (forall 'a, 'b. ('a | 'b
//│   where
//│     'a <: 'a -> 'b))

:e
res (choose id succ)
//│ res: int -> int | 'a
//│   where
//│     'b <: 'b -> 'a

// Didier Le Botlan suggested this fix by email:

let f = choose id in (f auto, f succ)
//│ res: (forall 'b. (forall 'a. 'a -> 'a & 'b) -> (forall 'b, 'c, 'd. ('b | 'd
//│   where
//│     'c <: 'c -> 'd)), forall 'b. (int & 'b) -> (int | 'b),)

let f = choose id in (f auto2, f succ)
//│ res: (forall 'a, 'b. ('a & 'b) -> (forall 'a, 'b, 'c. ('a | 'c
//│   where
//│     'b <: 'b -> 'c)), forall 'a. (int & 'a) -> (int | 'a),)

// ------------ Sec 6 ------------

// (λ(y) y I ; y K) (λ(x) x x)
// "typable in Fω but not in F [9]"
// [9] P. Giannini and S. R. D. Rocca. Characterization of typings in polymorphic type discipline. In Third annual Symposium on Logic in Computer Science, pages 61–70. IEEE, 1988.

// I := λx.x
I x = x
//│ I: 'a -> 'a

// K := λx.λy.x
K x y = x
//│ K: 'a -> anything -> 'a

(fun y -> let tmp = y I in y K) (fun x -> x x)
//│ res: 'a
//│   where
//│     'b <: (forall 'c. 'c -> anything -> 'c) -> 'a

// Note: reduces to
let tmp = (fun x -> x x) I in (fun x -> x x) K
//│ res: 'a
//│   where
//│     'b <: 'b -> 'a

// to
let tmp = I I in K K
//│ res: anything -> (forall 'a. 'a -> anything -> 'a)


// ============ Recasting MLF (2009) ============

// ------------ Sec 1.3 ------------

// ~ FreezeML B1
(fun f -> (f 42, f "foo")) (fun x -> x)
//│ res: ('a, 'b,)
//│   where
//│     'c <: 42 -> 'a & "foo" -> 'b

(fun f -> (f succ, choose f auto)) (choose id)
//│ res: ('b, (forall 'a. 'a -> 'a) -> (forall 'c, 'd. ('d
//│   where
//│     'c <: 'c -> 'd)) | 'e,)
//│   where
//│     'e <: (int -> int) -> 'b

// ------------ Sec 2.3.1 ------------

// i.e. id auto (FreezeML A5)
(fun z -> z) omegad
(fun z -> z) omega
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b, 'c. ('c
//│   where
//│     'b <: 'b -> 'c))
//│ res: 'a -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))

// i.e. auto id (FreezeML F5)
(fun x -> x x) id
//│ res: 'a
//│   where
//│     'b <: 'b -> 'a

fun z -> (z omegad)
fun z -> (z omega)
//│ res: 'b -> (forall 'b. ('c
//│   where
//│     'b <: ((forall 'a. 'a -> 'a) -> (forall 'd, 'e. ('e
//│   where
//│     'd <: 'd -> 'e))) -> 'c))
//│ res: 'a -> (forall 'a. ('b
//│   where
//│     'a <: (forall 'c. 'c -> (forall 'c, 'd. ('d
//│   where
//│     'c <: 'c -> 'd))) -> 'b))

(fun y -> fun z -> z y) omegad
(fun y -> fun z -> z y) omega
//│ res: 'b -> (forall 'b. ('c
//│   where
//│     'b <: ((forall 'a. 'a -> 'a) -> (forall 'd, 'e. ('e
//│   where
//│     'd <: 'd -> 'e))) -> 'c))
//│ res: 'a -> (forall 'a. ('b
//│   where
//│     'a <: (forall 'c. 'c -> (forall 'c, 'd. ('d
//│   where
//│     'c <: 'c -> 'd))) -> 'b))

fun z -> omegad z
fun z -> omega z
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b, 'c. ('c
//│   where
//│     'b <: 'b -> 'c))
//│ res: anything -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))

(fun x -> fun y -> x y) omegad
(fun x -> fun y -> x y) omega
//│ res: 'a -> (forall 'a, 'b. ('b
//│   where
//│     'c <: 'a -> 'b))
//│ res: 'a -> (forall 'a, 'b. ('b
//│   where
//│     'c <: 'a -> 'b))

// ------------ Sec 4.3 ------------
// affects the order of bindings in the result type in MLF, not very interesting otherwise

fun (x: forall 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a. 'a -> 'b -> 'a) -> (forall 'a. 'a -> 'b -> 'a)

fun (x: forall 'b 'a. 'a -> 'b -> 'a) -> x
//│ res: (forall 'a, 'b. 'a -> 'b -> 'a) -> (forall 'a, 'b. 'a -> 'b -> 'a)

// ============ Leijen 2007 ============

// ------------ Sec 2 ------------

// nope
poly = fun f -> (f 1, f true)
//│ poly: 'a -> (forall 'a, 'b, 'c. (('b, 'c,)
//│   where
//│     'a <: 1 -> 'b & true -> 'c))

// FreezeML B2
polyL = fun xs -> poly (head xs)
//│ polyL: 'a -> (forall 'a, 'b, 'c, 'd. (('c, 'd,)
//│   where
//│     'b <: 1 -> 'c & true -> 'd
//│     'a <: List['b]))

let ids = single id in (polyL ids, append ids (single inc))
//│ res: (forall 'a, 'b, 'c. (('b, 'c,)
//│   where
//│     'a <: 1 -> 'b & true -> 'c
//│     'd <: List[?]), List[int -> int],)

// ------------ Sec 5 ------------

// FreezeML C5
ids = single id
//│ ids: List[forall 'a. 'a -> 'a]

// Let-bound version of FreezeML A3
let f = choose nil in f ids
//│ res: List[forall 'a. 'a -> 'a]

// FreezeML A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]

def g: (int -> (forall 'a. 'a -> 'a)) -> int
//│ g: (int -> (forall 'a. 'a -> 'a)) -> int

g (fun x -> id)
//│ res: int

let f = fun x -> id in g f
//│ res: int

// FreezeML D4
app runST argST
//│ res: 'a
//│   where
//│     'b <: (forall 's. ST['s, int]) -> 'a

