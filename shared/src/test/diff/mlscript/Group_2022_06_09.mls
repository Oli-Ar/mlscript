
class Exp
//│ Defined class Exp

class Lit: { n: int } & Exp
class Add: { lhs: Exp; rhs: Exp } & Exp
//│ Defined class Lit
//│ Defined class Add

rec def eval e = case e of {
  | Lit -> e.n
  | Add -> eval e.lhs + eval e.rhs
  }
//│ eval: 'rhs -> int
//│   where
//│     'rhs <: (Add with {lhs: 'rhs, rhs: 'rhs}) | Lit
//│     = [Function: eval]

e = Add { lhs = Lit {n=1}; rhs = Lit {n=2} }
//│ e: Add with {lhs: Lit & {n: 1}, rhs: Lit & {n: 2}}
//│  = Add { lhs: Lit { n: 1 }, rhs: Lit { n: 2 } }

eval e
//│ res: int
//│    = 3


class Neg: { e: Exp } & Exp
//│ Defined class Neg

e2 = Neg { e }
//│ e2: Neg with {e: Add with {lhs: Lit & {n: 1}, rhs: Lit & {n: 2}}}
//│   = Neg { e: Add { lhs: Lit { n: 1 }, rhs: Lit { n: 2 } } }

e2.e.lhs.n
//│ res: 1
//│    = 1

:e
eval e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	eval e2
//│ ║        	^^^^^^^
//│ ╟── application of type `Neg & {e: ?e}` does not match type `Add & ?a | Lit & ?b`
//│ ║  l.31: 	e2 = Neg { e }
//│ ║        	     ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Add & ?c | Lit & ?d`
//│ ║  l.40: 	eval e2
//│ ║        	     ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.10: 	rec def eval e = case e of {
//│ ╙──      	                      ^
//│ res: error | int
//│ Runtime error:
//│   Error: non-exhaustive case expression


def eval eval e = case e of {
  | Lit -> e.n
  | Add -> eval eval e.lhs + eval eval e.rhs
  }
//│ eval: ('a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> 'b & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> 'b & 'a) -> (Add & 'b | (Lit with {n: 'n})) -> (int | 'n)
//│     = [Function: eval1]

:e
eval eval e
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.74: 	eval eval e
//│ ║        	^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α230    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α156'
//│ res: error
//│    = 3


def evalN evalN e = case e of {
  | Neg -> 0 - evalN evalN e.e
  | _ -> eval evalN e
  }
//│ evalN: nothing -> (Add | (Lit with {n: 'n}) | Neg) -> (int | 'n)
//│      = [Function: evalN]

:e
evalN eval e
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.93: 	evalN eval e
//│ ║        	^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α442    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α156'
//│ res: error
//│    = 3

:e
evalN eval e2
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.104: 	evalN eval e2
//│ ║         	^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α581    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α156' -> (α157' -> (n159' | α179')))›  <:  α156'
//│ res: error
//│    = -3

:e
ev = evalN evalN
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.115: 	ev = evalN evalN
//│ ║         	     ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α315' -> (α316' -> (α326' | α352')))›  <:  α700'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α315' -> (α316' -> (α326' | α352')))›  <:  α315'
//│ ev: error
//│   = [Function (anonymous)]

(ev e, ev e2)
//│ res: (error, error,)
//│    = [ 3, -3 ]


e3 = Add { lhs = Neg { e = Lit {n=1} }; rhs = Lit {n=2} }
//│ e3: Add with {lhs: Neg with {e: Lit & {n: 1}}, rhs: Lit & {n: 2}}
//│   = Add { lhs: Neg { e: Lit { n: 1 } }, rhs: Lit { n: 2 } }

ev e3
//│ res: error
//│    = 1


// * With a continuation, to make `evalN` not need to mention `eval` at all:

def evalN evalN k e = case e of {
  | Neg -> 0 - evalN evalN k e.e
  | _ -> k e
  }
//│ evalN: ('a -> 'b -> (forall 'c, 'e. ('e
//│   where
//│     'c <: {e: 'e})) -> int & 'a -> 'b -> (forall 'c, 'e. ('e
//│   where
//│     'c <: {e: 'e})) -> 'c & 'a) -> ('d -> 'f & 'b) -> (Neg & 'c | 'd & ~neg) -> (int | 'f)
//│      = [Function: evalN1]


:e
def evalComposed evalComposed = evalN evalN (fun e -> eval evalComposed e)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.154: 	def evalComposed evalComposed = evalN evalN (fun e -> eval evalComposed e)
//│ ║         	                                ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α867' -> (α868' -> (α869' -> (α881' | α887'))))›  <:  α932'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α867' -> (α868' -> (α869' -> (α881' | α887'))))›  <:  α867'
//│ evalComposed: ('a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> 'c & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> int & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> 'c & 'a -> (forall 'c, 'rhs0. ('rhs0
//│   where
//│     'c <: {rhs: 'rhs0})) -> int & 'a -> (forall 'c, 'rhs0. ('rhs0
//│   where
//│     'c <: {rhs: 'rhs0})) -> 'c & 'a -> (forall 'c, 'lhs0. ('lhs0
//│   where
//│     'c <: {lhs: 'lhs0})) -> int & 'a -> (forall 'c, 'lhs0. ('lhs0
//│   where
//│     'c <: {lhs: 'lhs0})) -> 'c & 'a -> (forall 'd, 'rhs1. ('rhs1
//│   where
//│     'd <: {rhs: 'rhs1})) -> int & 'a -> (forall 'd, 'rhs1. ('rhs1
//│   where
//│     'd <: {rhs: 'rhs1})) -> 'c & 'a -> (forall 'd, 'lhs1. ('lhs1
//│   where
//│     'd <: {lhs: 'lhs1})) -> int & 'a -> (forall 'd, 'lhs1. ('lhs1
//│   where
//│     'd <: {lhs: 'lhs1})) -> 'c & 'a -> (forall 'e, 'rhs2. ('rhs2
//│   where
//│     'e <: {rhs: 'rhs2})) -> int & 'a -> (forall 'e, 'rhs2. ('rhs2
//│   where
//│     'e <: {rhs: 'rhs2})) -> 'c & 'a -> (forall 'e, 'lhs2. ('lhs2
//│   where
//│     'e <: {lhs: 'lhs2})) -> 'c & 'a -> (forall 'e, 'lhs2. ('lhs2
//│   where
//│     'e <: {lhs: 'lhs2})) -> int & 'a) -> ((Add & 'e | (Lit with {n: 'n}) | (Neg with {e: Add & 'd & 'c | Lit | Neg})) -> (int | 'n) | error)
//│             = [Function: evalComposed]

:e
def evalComposed evalComposed = evalN evalN (eval evalComposed)
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.197: 	def evalComposed evalComposed = evalN evalN (eval evalComposed)
//│ ║         	                                ^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α867' -> (α868' -> (α869' -> (α881' | α887'))))›  <:  α1204'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α867' -> (α868' -> (α869' -> (α881' | α887'))))›  <:  α867'
//│ evalComposed: ('a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> 'c & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> int & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> 'c & 'a -> (forall 'c, 'rhs0. ('rhs0
//│   where
//│     'c <: {rhs: 'rhs0})) -> int & 'a -> (forall 'c, 'rhs0. ('rhs0
//│   where
//│     'c <: {rhs: 'rhs0})) -> 'c & 'a -> (forall 'c, 'lhs0. ('lhs0
//│   where
//│     'c <: {lhs: 'lhs0})) -> int & 'a -> (forall 'c, 'lhs0. ('lhs0
//│   where
//│     'c <: {lhs: 'lhs0})) -> 'c & 'a -> (forall 'd, 'rhs1. ('rhs1
//│   where
//│     'd <: {rhs: 'rhs1})) -> int & 'a -> (forall 'd, 'rhs1. ('rhs1
//│   where
//│     'd <: {rhs: 'rhs1})) -> 'c & 'a -> (forall 'd, 'lhs1. ('lhs1
//│   where
//│     'd <: {lhs: 'lhs1})) -> int & 'a -> (forall 'd, 'lhs1. ('lhs1
//│   where
//│     'd <: {lhs: 'lhs1})) -> 'c & 'a -> (forall 'e, 'rhs2. ('rhs2
//│   where
//│     'e <: {rhs: 'rhs2})) -> int & 'a -> (forall 'e, 'rhs2. ('rhs2
//│   where
//│     'e <: {rhs: 'rhs2})) -> 'c & 'a -> (forall 'e, 'lhs2. ('lhs2
//│   where
//│     'e <: {lhs: 'lhs2})) -> 'c & 'a -> (forall 'e, 'lhs2. ('lhs2
//│   where
//│     'e <: {lhs: 'lhs2})) -> int & 'a) -> ((Add & 'e | (Lit with {n: 'n}) | (Neg with {e: Add & 'd & 'c | Lit | Neg})) -> (int | 'n) | error)
//│             = [Function: evalComposed1]


:e
// * NOTE: This inferred type is a good example
// *    of the need for an algorithm to tie recursive TV knots and inline the rest;
// *    once we inline, `b` we should get the expected simplified recursive type.
ev2 = evalComposed evalComposed
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.244: 	ev2 = evalComposed evalComposed
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α1186' -> α1280')›  <:  α1543'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α1186' -> α1280')›  <:  α1186'
//│ ev2: error
//│    = [Function (anonymous)]

ev2 e3
//│ res: error
//│    = 1


def ev2_ty: (Add & { lhs: 'a; rhs: 'a } | Lit | Neg & { e: 'a } as 'a) -> int
//│ ev2_ty: 'a -> int
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {e: 'a})
//│       = <missing implementation>

ev2_ty = ev2
//│ error
//│   <:  ev2_ty:
//│ 'a -> int
//│   where
//│     'a <: (Add with {lhs: 'a, rhs: 'a}) | Lit | (Neg with {e: 'a})
//│       = [Function (anonymous)]

