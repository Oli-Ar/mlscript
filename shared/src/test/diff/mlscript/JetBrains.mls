
class Expr
class Lit: Expr & { val: int }
class Add: Expr & { lhs: Expr; rhs: Expr }
//│ Defined class Expr
//│ Defined class Lit
//│ Defined class Add

rec def eval x = case x of {
  Lit -> x.val
  | Add -> eval x.lhs + eval x.rhs
  }
//│ eval: 'rhs -> int
//│   where
//│     'rhs <: (Add with {lhs: 'rhs, rhs: 'rhs}) | Lit
//│     = [Function: eval]

def eval eval x = case x of {
  Lit -> x.val
  | Add -> eval eval x.lhs + eval eval x.rhs
  }
//│ eval: ('a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> 'b & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> 'b & 'a) -> (Add & 'b | (Lit with {val: 'val})) -> (int | 'val)
//│     = [Function: eval1]

:e
eval eval
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.34: 	eval eval
//│ ║        	^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α54' -> (α55' -> (val57' | α77')))›  <:  α128    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α54' -> (α55' -> (val57' | α77')))›  <:  α54'
//│ res: error
//│    = [Function (anonymous)]

class Neg: Expr & { underlying: Expr }
//│ Defined class Neg

def evalN evalN x = case x of {
  Neg -> 0 - (evalN evalN x.underlying)
  | _ -> eval evalN x
  }
//│ evalN: nothing -> (Add | (Lit with {val: 'val}) | Neg) -> (int | 'val)
//│      = [Function: evalN]

:e
evalN evalN
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.55: 	evalN evalN
//│ ║        	^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α214' -> (α215' -> (α225' | α251')))›  <:  α321    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α214' -> (α215' -> (α225' | α251')))›  <:  α214'
//│ res: error
//│    = [Function (anonymous)]

e = Add{lhs = Lit{val = 1}; rhs = Neg{underlying = Lit{val = 2}}}
//│ e: Add with {lhs: Lit & {val: 1}, rhs: Neg with {underlying: Lit & {val: 2}}}
//│  = Add { lhs: Lit { val: 1 }, rhs: Neg { underlying: Lit { val: 2 } } }

:e
evalN evalN e
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.70: 	evalN evalN e
//│ ║        	^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α214' -> (α215' -> (α225' | α251')))›  <:  α513    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α214' -> (α215' -> (α225' | α251')))›  <:  α214'
//│ res: error
//│    = -1




// === === === ERROR CASES === === === //



:ShowRelativeLineNums
:AllowTypeErrors



:e
def evalN2 evalN2 x = case x of {
  Neg -> 0 - (evalN2 evalN2 x.underlying)
  | _ -> eval eval x
  }
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.+3: 	  | _ -> eval eval x
//│ ║        	         ^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α54' -> (α55' -> (val57' | α77')))›  <:  α687'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α54' -> (α55' -> (val57' | α77')))›  <:  α54'
//│ evalN2: ('a -> (forall 'b, 'underlying. ('underlying
//│   where
//│     'b <: {underlying: 'underlying})) -> int & 'a -> (forall 'b, 'underlying. ('underlying
//│   where
//│     'b <: {underlying: 'underlying})) -> 'b & 'a) -> (Neg & 'b | ~Neg) -> (error | int)

:e
evalN2 evalN2 e
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.+1: 	evalN2 evalN2 e
//│ ║        	^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α650' -> (α651' -> (α661' | α770')))›  <:  α802    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α650' -> (α651' -> (α661' | α770')))›  <:  α650'
//│ res: error | int


def evalN3 evalN3 x = case x of {
  Neg -> 0 - (evalN2 x.underlying)
  | _ -> eval evalN3 x
  }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c)` is not an instance of type `int`
//│ ║  l.93: 	def evalN2 evalN2 x = case x of {
//│ ║        	                  ^^^^^^^^^^^^^^^
//│ ║  l.94: 	  Neg -> 0 - (evalN2 evalN2 x.underlying)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.95: 	  | _ -> eval eval x
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ║  l.96: 	  }
//│ ║        	^^^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.+2: 	  Neg -> 0 - (evalN2 x.underlying)
//│ ╙──      	              ^^^^^^^^^^^^^^^^^^^
//│ evalN3: ('a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> 'c & 'a -> (forall 'b, 'lhs. ('lhs
//│   where
//│     'b <: {lhs: 'lhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> int & 'a -> (forall 'b, 'rhs. ('rhs
//│   where
//│     'b <: {rhs: 'rhs})) -> 'c & 'a) -> (Add & 'b | (Lit with {val: 'val}) | (Neg with {underlying: (forall 'c, 'underlying. ('underlying
//│   where
//│     'c <: {underlying: 'underlying})) -> (forall 'd, 'underlying0. ('underlying0
//│   where
//│     'd <: {underlying: 'underlying0})) -> int & (forall 'c, 'underlying. ('underlying
//│   where
//│     'c <: {underlying: 'underlying})) -> (forall 'd, 'underlying0. ('underlying0
//│   where
//│     'd <: {underlying: 'underlying0})) -> 'c & (forall 'c, 'underlying. ('underlying
//│   where
//│     'c <: {underlying: 'underlying})) -> (forall 'e, 'underlying1. ('underlying1
//│   where
//│     'e <: {underlying: 'underlying1})) -> 'c & (forall 'c, 'underlying. ('underlying
//│   where
//│     'c <: {underlying: 'underlying})) -> (forall 'e, 'underlying1. ('underlying1
//│   where
//│     'e <: {underlying: 'underlying1})) -> int}) & 'c) -> (error | int | 'val)

def evalN3 evalN3 x = case x of {
  Neg -> 0 - (evalN3 x.underlying)
  | _ -> eval evalN3 x
  }
//│ evalN3: ((forall 'a, 'underlying. ('underlying
//│   where
//│     'a <: {underlying: 'underlying})) -> 'a & (forall 'a, 'underlying. ('underlying
//│   where
//│     'a <: {underlying: 'underlying})) -> int & 'b -> (forall 'c, 'lhs. ('lhs
//│   where
//│     'c <: {lhs: 'lhs})) -> 'a & 'b -> (forall 'c, 'lhs. ('lhs
//│   where
//│     'c <: {lhs: 'lhs})) -> int & 'b -> (forall 'c, 'rhs. ('rhs
//│   where
//│     'c <: {rhs: 'rhs})) -> int & 'b -> (forall 'c, 'rhs. ('rhs
//│   where
//│     'c <: {rhs: 'rhs})) -> 'a & 'b) -> (Add & 'c | (Lit with {val: 'val}) | Neg & 'a) -> (int | 'val)

:e
evalN3 evalN3 e
//│ ╔══[ERROR] Cyclic-looking constraint while typing application
//│ ║  l.+1: 	evalN3 evalN3 e
//│ ║        	^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. (α989' -> (α990' -> (α998' | α1023')))›  <:  α1095    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. (α989' -> (α990' -> (α998' | α1023')))›  <:  α989'
//│ res: error


