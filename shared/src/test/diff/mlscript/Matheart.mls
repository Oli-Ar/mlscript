// testing cases for various `case` in constrainIndex 
("haha", 1)[0]
//│ res: "haha"
//│    = 'haha'

:e
(1, 2, 3)[true]
//│ ╔══[ERROR] The index must be an integer
//│ ╙──
//│ res: error
//│    = undefined

:e
(1, 2, 3)[false]
//│ ╔══[ERROR] The index must be an integer
//│ ╙──
//│ res: error
//│    = undefined

:e
def my_str: string
my_str = "h"
(1, 2, 3)[my_str]
//│ my_str: string
//│       = <missing implementation>
//│ "h"
//│   <:  my_str:
//│ string
//│       = 'h'
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.21: 	def my_str: string
//│ ╙──      	            ^^^^^^
//│ res: error
//│    = undefined

:e
def my_a = false : bool
(1, 2, 3)[my_a]
//│ my_a: bool
//│     = false
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.37: 	def my_a = false : bool
//│ ╙──      	                   ^^^^
//│ res: error
//│    = undefined

:e
(1, 2, 3)[false: bool]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.48: 	(1, 2, 3)[false: bool]
//│ ╙──      	                 ^^^^
//│ res: error
//│    = undefined

:e
(1, 2, 3)[false || true]
//│ ╔══[ERROR] The index must be an integer
//│ ╙──
//│ res: error
//│    = undefined

:e
(1, 2, 3)["true"]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.63: 	(1, 2, 3)["true"]
//│ ╙──      	          ^^^^^^
//│ res: error
//│    = undefined

:e
def s: string
(1, 2, 3)[s]
//│ s: string
//│  = <missing implementation>
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.71: 	def s: string
//│ ╙──      	       ^^^^^^
//│ res: error
//│    = <no result>
//│      s is not implemented

:e
(1, 2, 3)[concat "true"  "bruh"]
//│ ╔══[ERROR] The index must be an integer
//│ ╙──
//│ res: error
//│    = undefined

concat "true" "bruh"
//│ res: string
//│    = 'truebruh'

:e
(1, 2, 3)["haha"]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.94: 	(1, 2, 3)["haha"]
//│ ╙──      	          ^^^^^^
//│ res: error
//│    = undefined

:pe
(1, 2, 3)[-10]
//│ /!\ Parse error: Expected end-of-input:1:10, found "[-10];" at l.102:10: (1, 2, 3)[-10]


(1, 2, 3)[0]
//│ res: 1
//│    = 1

(1, 2, 3)[1]
//│ res: 2
//│    = 2

:e
(1, 2, 3)[3]
//│ ╔══[ERROR] Out of range!
//│ ║  l.115: 	(1, 2, 3)[3]
//│ ╙──       	^^^^^^^^^
//│ res: error
//│    = undefined

a = 2
(1, 2, 3)[a]
//│ a: 2
//│  = 2
//│ res: 3
//│    = 3

a = 1 + 1
(1, 2, 3)[a]
//│ a: int
//│  = 2
//│ res: 1 | 2 | 3 | undefined
//│    = 3

(1, 2, 3)[1 + 1]
//│ res: 1 | 2 | 3 | undefined
//│    = 3

(1 + 1, 2, 3)[0]
//│ res: int
//│    = 2

(1, "haha")[0]
//│ res: 1
//│    = 1

(1, "haha")[1]
//│ res: "haha"
//│    = 'haha'

zh = "你好"
//│ zh: "你好"
//│   = '′0⊐9'

ch = "मनीष منش" 
//│ ch: "मनीष منش"
//│   = '⍐⍄⍨⍙ ᘅᘆᖈ'

:e
"foo"[2]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.161: 	"foo"[2]
//│ ║         	^^^^^^^^
//│ ╟── string literal of type `"foo"` does not match type `Array[~undefined]`
//│ ║  l.161: 	"foo"[2]
//│ ╙──       	^^^^^
//│ ╔══[ERROR] mlscript doesn't allow string indexing
//│ ║  l.161: 	"foo"[2]
//│ ╙──       	^^^^^
//│ res: error
//│    = 'o'

:e
"foo"[3]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.175: 	"foo"[3]
//│ ║         	^^^^^^^^
//│ ╟── string literal of type `"foo"` does not match type `Array[~undefined]`
//│ ║  l.175: 	"foo"[3]
//│ ╙──       	^^^^^
//│ ╔══[ERROR] mlscript doesn't allow string indexing
//│ ║  l.175: 	"foo"[3]
//│ ╙──       	^^^^^
//│ res: error
//│    = undefined

('f', 'o', 'o')[2]
//│ res: "o"
//│    = 'o'

(1, 2, 3)[(1, 2, 3)[0]]
//│ res: 2
//│    = 2

(1, 2, 3)[(1, 2, 3)[(1, 2, 3)[0]]]
//│ res: 3
//│    = 3

:e
(1, 2, 3)[(1, 2, 3)[(1, 2, 3)[(1, 2, 3)[0]]]]
//│ ╔══[ERROR] Out of range!
//│ ║  l.201: 	(1, 2, 3)[(1, 2, 3)[(1, 2, 3)[(1, 2, 3)[0]]]]
//│ ╙──       	^^^^^^^^^
//│ res: error
//│    = undefined

:e
:ge
(1, 2, 3)[k]
//│ ╔══[ERROR] identifier not found: k
//│ ║  l.210: 	(1, 2, 3)[k]
//│ ╙──       	          ^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol k

:e
3[1]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.219: 	3[1]
//│ ║         	^^^^
//│ ╟── integer literal of type `3` does not match type `Array[~undefined]`
//│ ║  l.219: 	3[1]
//│ ╙──       	^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ║  l.219: 	3[1]
//│ ╙──       	^
//│ res: error
//│    = undefined

:e
def k: int
k[1]
//│ k: int
//│  = <missing implementation>
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.234: 	k[1]
//│ ║         	^^^^
//│ ╟── type `int` does not match type `Array[~undefined]`
//│ ║  l.233: 	def k: int
//│ ║         	       ^^^
//│ ╟── but it flows into reference with expected type `Array[~undefined]`
//│ ║  l.234: 	k[1]
//│ ╙──       	^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ║  l.233: 	def k: int
//│ ╙──       	       ^^^
//│ res: error
//│    = <no result>
//│      k is not implemented

:e
(1 + 1)[0]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.254: 	(1 + 1)[0]
//│ ║         	^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `Array[~undefined]`
//│ ║  l.254: 	(1 + 1)[0]
//│ ╙──       	 ^^^^^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ╙──
//│ res: error
//│    = undefined

def k: int
k = 0
(1, 2, 3)[k]
//│ k: int
//│  = <missing implementation>
//│ 0
//│   <:  k:
//│ int
//│  = 0
//│ res: 1 | 2 | 3 | undefined
//│    = 1

:e
def k = 1 + 1: int
def i: int
k[i + 1]
//│ int
//│   <:  k:
//│ int
//│  = 2
//│ i: int
//│  = <missing implementation>
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.281: 	k[i + 1]
//│ ║         	^^^^^^^^
//│ ╟── type `int` does not match type `Array[~undefined]`
//│ ║  l.266: 	def k: int
//│ ║         	       ^^^
//│ ╟── but it flows into reference with expected type `Array[~undefined]`
//│ ║  l.281: 	k[i + 1]
//│ ╙──       	^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ║  l.266: 	def k: int
//│ ╙──       	       ^^^
//│ res: error
//│    = <no result>
//│      i is not implemented


def haha : Array[string]
haha = ("hello", "world", "!")
//│ haha: Array[string]
//│     = <missing implementation>
//│ ("hello", "world", "!",)
//│   <:  haha:
//│ Array[string]
//│     = [ 'hello', 'world', '!' ]

:pe
haha[-1]
//│ /!\ Parse error: Expected end-of-input:1:5, found "[-1];" at l.315:5: haha[-1]

haha[4]
//│ res: string | undefined
//│    = undefined

haha[2 + 2]
//│ res: string | undefined
//│    = undefined

def k: int
k = 0
haha[k]
//│ k: int
//│  = <missing implementation>
//│ 0
//│   <:  k:
//│ int
//│  = 0
//│ res: string | undefined
//│    = 'hello'

def haha2 : Array[int] // arraybase
haha2[0]
//│ haha2: Array[int]
//│      = <missing implementation>

:e
my_record = {x = (1,2); y = 2}
my_record.x[my_record.y]
//│ my_record: {x: (1, 2,), y: 2}
//│          = { x: [ 1, 2 ], y: 2 }
//│ ╔══[ERROR] Out of range!
//│ ║  l.344: 	my_record = {x = (1,2); y = 2}
//│ ╙──       	                 ^^^^^
//│ res: error
//│    = undefined

:e
def my_func x = (1, 2, 3)
my_func[0]
//│ my_func: anything -> (1, 2, 3,)
//│        = [Function: my_func]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.356: 	my_func[0]
//│ ║         	^^^^^^^^^^
//│ ╟── function of type `?a -> (1, 2, 3,)` does not match type `Array[~undefined]`
//│ ║  l.355: 	def my_func x = (1, 2, 3)
//│ ║         	            ^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Array[~undefined]`
//│ ║  l.356: 	my_func[0]
//│ ╙──       	^^^^^^^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ║  l.355: 	def my_func x = (1, 2, 3)
//│ ╙──       	            ^^^^^^^^^^^^^
//│ res: error
//│    = undefined


(my_func 3)[0]
//│ res: 1
//│    = 1

:e
(1, 2, 3)[my_func 0]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.355: 	def my_func x = (1, 2, 3)
//│ ╙──       	                ^^^^^^^^^
//│ res: error
//│    = undefined

:e
(1, 2, 3)[(1, 2)]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.388: 	(1, 2, 3)[(1, 2)]
//│ ╙──       	          ^^^^^^
//│ res: error
//│    = undefined

:e
(1, 2, 3)[my_func]
//│ ╔══[ERROR] The index must be an integer
//│ ║  l.355: 	def my_func x = (1, 2, 3)
//│ ╙──       	            ^^^^^^^^^^^^^
//│ res: error
//│    = undefined

(1, 2, 3)[(my_func 3)[0]]
//│ res: 2
//│    = 2

pick_arr = (1, 3, 0, 2)
rec def pick n m = if m > 0 then (pick pick_arr[n] (m-1)) else n
//│ pick_arr: (1, 3, 0, 2,)
//│         = [ 1, 3, 0, 2 ]
//│ pick: 'a -> int -> 'a
//│     = [Function: pick]

pick 1 5
//│ res: 1
//│    = 3

(case (1) of {1 ->  (1, 2) | 2 -> (3, 4) })[0]
//│ res: 1 | 3
//│    = 1

a = if true then (0,1) else (3,4,5)
//│ a: Array[0 | 1 | 3 | 4 | 5] & {_1: 0 | 3, _2: 1 | 4}
//│  = [ 0, 1 ]

i = if true then 0 else 1
//│ 0 | 1
//│   <:  i:
//│ int
//│  = 0

a[i]
//│ res: 0 | 1 | 3 | 4 | 5 | undefined
//│    = 0

def a: (1,2) | (3,4,5)
//│ a: Array[1 | 2 | 3 | 4 | 5] & {_1: 1 | 3, _2: 2 | 4}
//│  = <missing implementation>

def i: 0 | 1
//│ i: 0 | 1
//│  = <missing implementation>

a[0]
//│ res: 1 | 3
//│    = <no result>
//│      a is not implemented


a[i]
//│ res: 1 | 2 | 3 | 4
//│    = <no result>
//│      a is not implemented

(1, 2, 3)[i]
//│ res: 1 | 2
//│    = <no result>
//│      i is not implemented

def a:  (0, 1, 2) & {x: 1} // {x: 1} fieldtype
//│ a: (0, 1, 2,) & {x: 1}
//│  = <missing implementation>

//:e
//a[0] 

:e
({x = 1} & {y = 1}).x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.468: 	({x = 1} & {y = 1}).x
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── receiver of type `{_1: {x: 1, y: 1}}` does not have field 'x'
//│ ║  l.468: 	({x = 1} & {y = 1}).x
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ res: error
//│    = undefined

:e
({x = 1})[0]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.479: 	({x = 1})[0]
//│ ║         	^^^^^^^^^^^^
//│ ╟── record literal of type `{x: 1}` does not match type `Array[~undefined]`
//│ ║  l.479: 	({x = 1})[0]
//│ ╙──       	 ^^^^^^^
//│ ╔══[ERROR] The indexing operation should be acted on an array
//│ ║  l.479: 	({x = 1})[0]
//│ ╙──       	 ^^^^^^^
//│ res: error
//│    = undefined

def ar: (Array[0 | 1] & Array[1 | 2])
//│ ar: Array[1]
//│   = <missing implementation>

def foo x y = let inner a b = (x[a], b[y]) in inner
//│ foo: Array[~undefined] -> anything -> anything -> Array[~undefined] -> (nothing, nothing,)
//│    = [Function: foo]

kk = (0: int): int
//│ kk: int
//│   = 0

(1, 2, 3)[kk]
//│ res: 1 | 2 | 3 | undefined
//│    = 1


def foo x = x[1] // modify the Simplifier to adapt tp new change
//│ foo: Array[~undefined] -> nothing
//│    = [Function: foo1]


foo ((1, 2, 3))
//│ res: nothing
//│    = 2

nw = (1, 2, 3, 4, 5)
def chose i = nw[i]
//│ nw: (1, 2, 3, 4, 5,)
//│   = [ 1, 2, 3, 4, 5 ]
//│ chose: anything -> nothing
//│      = [Function: chose]

chose 2
//│ res: nothing
//│    = 3
