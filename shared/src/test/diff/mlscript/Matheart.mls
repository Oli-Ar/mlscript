1+2
//│ res: int
//│    = 3

record = {a = 1}
record.a
//│ record: {a: 1}
//│       = { a: 1 }
//│ res: 1
//│    = 1

def z: Array[int]
z = (3, 5, 6)
z[1]
//│ z: Array[int]
//│  = <missing implementation>
//│ (3, 5, 6,)
//│   <:  z:
//│ Array[int]
//│  = [ 3, 5, 6 ]
//│ res: int | undefined
//│    = 5


//y = (3, "hello", 5.4)

def st: Array[string] 
st = ("hello", "world", "!")
st[0]
//│ st: Array[string]
//│   = <missing implementation>
//│ ("hello", "world", "!",)
//│   <:  st:
//│ Array[string]
//│   = [ 'hello', 'world', '!' ]
//│ res: string | undefined
//│    = 'hello'

def ud: Array[int]
ud[0]
//│ ud: Array[int]
//│   = <missing implementation>
//│ res: int | undefined
//│    = <no result>
//│      ud is not implemented

def precise: Array[int] 
precise = (3: int, 5:int, 9:int)
precise[2]
precise[3]
//│ precise: Array[int]
//│        = <missing implementation>
//│ (int, int, int,)
//│   <:  precise:
//│ Array[int]
//│        = [ 3, 5, 9 ]
//│ res: int | undefined
//│    = 9
//│ res: int | undefined
//│    = undefined

class Lit: {val: int}
class Add[E]: { lhs: E; rhs: E }
class Nega[E]: { arg: E}
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
def nega arg = Nega { arg }
//│ Defined class Lit
//│ Defined class Add[+E]
//│ Defined class Nega[+E]
//│ lit: (int & 'val) -> (Lit with {val: 'val})
//│    = [Function: lit]
//│ add: ('lhs & 'E) -> ('E & 'rhs) -> (Add['E] with {lhs: 'lhs, rhs: 'rhs})
//│    = [Function: add]
//│ nega: 'arg -> Nega['arg]
//│     = [Function: nega]

rec def evalStub1 e = case e of {
    Lit -> e.val
    }
//│ evalStub1: (Lit with {val: 'val}) -> 'val
//│          = [Function: evalStub1]

rec def evalStub2 e = case e of {
    Lit -> e.val | Nega -> 0 - (evalStub2 e.arg)
    }
//│ evalStub2: 'a -> int
//│   where
//│     'a <: Lit | Nega[?] & {arg: 'a}
//│          = [Function: evalStub2]

rec def eval e = case e of {
    | Lit -> e.val 
    | Add -> eval e.lhs + eval e.rhs
    | Nega -> 0 - (eval e.arg)
    }
//│ eval: 'a -> int
//│   where
//│     'a <: Add[?] & {lhs: 'a, rhs: 'a} | Lit | Nega[?] & {arg: 'a}
//│     = [Function: eval]

def ex = add (lit 2) (lit 2)
//│ ex: Add[Lit & {val: 2}]
//│   = Add { lhs: Lit { val: 2 }, rhs: Lit { val: 2 } }

eval ex
//│ res: int
//│    = 4

def e: Add['e] as 'e
//│ e: 'e
//│   where
//│     'e :> Add['e]
//│  = <missing implementation>

def e: Lit | Add['e] | Nega['e] as 'e
def e = ex
//│ e: 'e
//│   where
//│     'e :> Add['e] | Lit | Nega['e]
//│  = <missing implementation>
//│ Add[Lit & {val: 2}]
//│   <:  e:
//│ 'e
//│   where
//│     'e :> Add['e] | Lit | Nega['e]
//│  = Add { lhs: Lit { val: 2 }, rhs: Lit { val: 2 } }

class Automata
class Binding
//│ Defined class Automata
//│ Defined class Binding

:e
def exp: Array[Automata] -> Array[Binding]
eval exp
//│ exp: Array[Automata] -> Array[Binding]
//│    = <missing implementation>
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.136: 	eval exp
//│ ║         	^^^^^^^^
//│ ╟── type `Array[Automata] -> Array[Binding]` does not match type `Add[?] & ?a | Lit & ?b | Nega[?] & ?c`
//│ ║  l.135: 	def exp: Array[Automata] -> Array[Binding]
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Add[?] & ?d | Lit & ?e | Nega[?] & ?f`
//│ ║  l.136: 	eval exp
//│ ║         	     ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.92: 	rec def eval e = case e of {
//│ ╙──      	                      ^
//│ res: error | int
//│    = <no result>
//│      exp is not implemented

:e
eval (e: Lit | Add['e'] | Nega[int] as 'e)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.156: 	eval (e: Lit | Add['e'] | Nega[int] as 'e)
//│ ║         	      ^
//│ ╟── type `Lit` is not an instance of type `int`
//│ ║  l.116: 	def e: Lit | Add['e] | Nega['e] as 'e
//│ ║         	       ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.156: 	eval (e: Lit | Add['e'] | Nega[int] as 'e)
//│ ╙──       	                               ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.156: 	eval (e: Lit | Add['e'] | Nega[int] as 'e)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `Add[?] & ?a | Lit & ?b | Nega[?] & ?c`
//│ ║  l.156: 	eval (e: Lit | Add['e'] | Nega[int] as 'e)
//│ ║         	                               ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.92: 	rec def eval e = case e of {
//│ ║        	                      ^
//│ ╟── from field selection:
//│ ║  l.95: 	    | Nega -> 0 - (eval e.arg)
//│ ╙──      	                        ^^^^^
//│ res: error | int
//│    = 4

class MyArray[A]: { size: int; set: (int, A) -> (); get: int -> A}
//│ Defined class MyArray[=A]

dummy = MyArray {
    size = 0;
    set = fun (i, a) -> ();
    get = fun i -> error
  }
//│ dummy: MyArray['A] with {get: anything -> nothing, set: (anything, anything,) -> (), size: 0}
//│      = MyArray { size: 0, set: [Function: set], get: [Function: get] }

dummy: MyArray[int]
//│ res: MyArray[int]
//│    = MyArray { size: 0, set: [Function: set], get: [Function: get] }

def ty2A: MyArray['a]
//│ ty2A: MyArray['a]
//│     = <missing implementation>

:stats
ty2A = ty2A
//│ MyArray['a]
//│   <:  ty2A:
//│ MyArray['a]
//│     = <no result>
//│       ty2A is not implemented
//│ constrain calls  : 9
//│ annoying  calls  : 0
//│ subtyping calls  : 0

def ty2B: MyArray[MyArray['a]]
//│ ty2B: MyArray[MyArray['a]]
//│     = <missing implementation>

:stats
ty2B = ty2A
//│ MyArray['a]
//│   <:  ty2B:
//│ MyArray[MyArray['a]]
//│     = <no result>
//│       ty2A and ty2A are not implemented
//│ constrain calls  : 7
//│ annoying  calls  : 0
//│ subtyping calls  : 0
