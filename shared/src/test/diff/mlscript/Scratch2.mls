
:GeneralizeCurriedFunctions

test1 f =
  (f 0, f true)
//│ test1: (true -> 'a & 0 -> 'b) -> ('b, 'a,)
//│      = [Function: test1]

test1 (fun value -> { value })
//│ res: ({value: 0}, {value: true},)
//│    = [ undefined, undefined ]

// :ns
// :d
test2 f =
  let r x = f x
  in (r 0, r true)
//│ test2: (true -> 'a & 0 -> 'b) -> ('b, 'a,)
//│      = [Function: test2]

test2 (fun value -> { value })
//│ res: ({value: 0}, {value: true},)
//│    = [ undefined, undefined ]


type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ Defined type alias ChurchInt

// :ns
def s n = fun f -> fun x -> f (n f x)
//│ s: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'a
//│     'b <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'e)) -> 'd)))
//│  = [Function: s]

// :ns
def s' (n: ChurchInt) = fun f -> fun x -> f (n f x)
//│ s': ChurchInt -> (forall 'a. 'a -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'b <: 'a -> 'c -> 'e)) -> 'd)))
//│   = [Function: s]

def succ: ChurchInt -> ChurchInt
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>

// :ns
:e // * Needs distrib (see below)
succ = s
//│ 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'a
//│     'b <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'e)) -> 'd)))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.55: 	succ = s
//│ ║        	^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──      	                        ^^
//│     = [Function: s]

def succD: forall 'M. ChurchInt -> ('M -> 'M) -> ('M -> 'M)
//│ succD: ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = <missing implementation>

succD = s
//│ 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'a
//│     'b <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'e)) -> 'd)))
//│   <:  succD:
//│ ChurchInt -> ('M -> 'M) -> 'M -> 'M
//│      = [Function: s]


def z f x = x
//│ z: anything -> (forall 'a. 'a -> 'a)
//│  = [Function: z]

def zero: ChurchInt
//│ zero: ChurchInt
//│     = <missing implementation>

def zero = z
//│ anything -> (forall 'a. 'a -> 'a)
//│   <:  zero:
//│ ChurchInt
//│     = [Function: z]


wrap x = { x }
//│ wrap: 'a -> {x: 'a}
//│     = [Function: wrap]

n1 = s z
//│ n1: 'a -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'b <: 'a -> 'c -> 'e)) -> 'd))
//│   = [Function (anonymous)]

n1 wrap 0
//│ res: {x: 'a
//│   where
//│     'b <: (forall 'c. 'c -> {x: 'c}) -> 0 -> 'a}
//│    = { x: 0 }

n2 = s (s z)
//│ n2: 'a -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'b <: 'a -> 'c -> 'e)) -> 'd))
//│   = [Function (anonymous)]

n2 wrap 0
//│ res: {x: 'a
//│   where
//│     'b <: (forall 'c. 'c -> {x: 'c}) -> 0 -> 'a}
//│    = { x: { x: 0 } }

n3 = s (s (s z))
//│ n3: 'a -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'b <: 'a -> 'c -> 'e)) -> 'd))
//│   = [Function (anonymous)]




// :ns
// :d
// rec def to_ch_simpl n =
//   if n == 0 then zero
//   else to_ch_simpl n
// rec def to_ch_simpl n =
//   to_ch_simpl n

// :d
// to_ch_simpl

// :ns
rec def to_ch n =
  if n == 0 then zero
  else succ (to_ch (n - 1))
//│ to_ch: int -> ChurchInt
//│      = [Function: to_ch]

def to_ch_s_mix n =
  if n == 0 then z
  else s (to_ch (n - 1))
//│ to_ch_s_mix: int -> (forall 'a. 'a -> (forall 'a, 'b, 'c. (('d & 'c) -> ('d | 'e)
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'f. ('f
//│   where
//│     'b <: 'a -> 'c -> 'f)) -> 'e)))
//│            = [Function: to_ch_s_mix]

rec def to_ch_s n =
  if n == 0 then z
  else s (to_ch_s (n - 1))
//│ to_ch_s: int -> ((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'b & (forall 'a, 'f, 'g, 'h. ('h
//│   where
//│     'a <: 'f -> 'g -> 'h)) -> anything & 'f) -> (forall 'c, 'e. ('e & 'c & 'g) -> 'e)
//│        = [Function: to_ch_s]

// rec def to_ch n =
//   (if n == 0 then zero
//   else succ (to_ch (n - 1) : ChurchInt)): ChurchInt

def to_church: int -> ChurchInt
//│ to_church: int -> ChurchInt
//│          = <missing implementation>

def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ int -> ChurchInt
//│   <:  to_church:
//│ int -> ChurchInt
//│          = <no result>
//│            to_church is not implemented

to_church = to_ch
//│ int -> ChurchInt
//│   <:  to_church:
//│ int -> ChurchInt
//│          = [Function: to_ch]

// :s
// :ns
// :e // * Needs distrib (see below)
to_church = to_ch_s_mix
//│ int -> (forall 'a. 'a -> (forall 'a, 'b, 'c. (('d & 'c) -> ('d | 'e)
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'f. ('f
//│   where
//│     'b <: 'a -> 'c -> 'f)) -> 'e)))
//│   <:  to_church:
//│ int -> ChurchInt
//│          = [Function: to_ch_s_mix]

// FIXME why doesn't this raise a cycle error?
:e // * Needs distrib (see below)
to_church = to_ch_s
//│ int -> ((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'b & (forall 'a, 'f, 'g, 'h. ('h
//│   where
//│     'a <: 'f -> 'g -> 'h)) -> anything & 'f) -> (forall 'c, 'e. ('e & 'c & 'g) -> 'e)
//│   <:  to_church:
//│ int -> ChurchInt
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a, ?b, ?c, ?d, ?e, ?f, ?g, ?h, ?i, ?j, ?k, ?l, ?m, ?to_ch_s, ?n, ?o, ?p, ?q, ?r, ?s, ?t, ?u, ?v, ?w, ?x, ?y. ?to_ch_s <: int -> ChurchInt` exceeded recursion depth limit (400)
//│ ║  l.230: 	to_church = to_ch_s
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── while constraining:  (⊥ -> ⊤)  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α776'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α782'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α791'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α800'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α809'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α818'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α827'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α836'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α845',) -> α846''''')}›,) -> α755')
//│ ╟── while constraining:  α836'  <!<  ((‹∀ 4. {α844''''' where: α746' <: ((α842'',) -> α843''''')}›,) -> α755')
//│ ╟── while constraining:  α836'  <!<  α842''
//│ ╟── while constraining:  (α836',)  <!<  (α842'',)
//│ ╟── while constraining:  (α842'' -> ‹∀ 3. (α747'''' -> α754'''')›)  <!<  ((α836',) -> α840')
//│ ╟── while constraining:  ‹∀ 2. (α745''' -> ‹∀ 3. (α747'''' -> α754'''')›)›  <!<  ((α836',) -> α840')
//│ ╟── while constraining:  α746'  <!<  ((α836',) -> α840')
//│ ╟── ......
//│ ╟── ......
//│ ╟── while constraining:  ‹∀ 4. {α773''''' where: α746' <: ((α771'',) -> α772''''')}›  <!<  ‘N''
//│ ╟── while constraining:  (‹∀ 4. {α773''''' where: α746' <: ((α771'',) -> α772''''')}›,)  <!<  (‘N'',)
//│ ╟── while constraining:  (‘N'' -> ‘N'')  <!<  ((‹∀ 4. {α773''''' where: α746' <: ((α771'',) -> α772''''')}›,) -> α755')
//│ ╟── while constraining:  (‘N'' -> ‘N'')  <!<  α771''
//│ ╟── while constraining:  ((‘N'' -> ‘N''),)  <!<  (α771'',)
//│ ╟── while constraining:  (α771'' -> ‹∀ 3. (α747'''' -> α754'''')›)  <!<  ((‘N'' -> ‘N'') -> (‘N'' -> ‘N''))
//│ ╟── while constraining:  ‹∀ 2. (α745''' -> ‹∀ 3. (α747'''' -> α754'''')›)›  <!<  ((‘N'' -> ‘N'') -> (‘N'' -> ‘N''))
//│ ╟── while constraining:  ‹∀ 2. (α745''' -> ‹∀ 3. (α747'''' -> α754'''')›)›  <!<  ‹∀ 0. (('N79' -> 'N79') -> ('N79' -> 'N79'))›
//│ ╟── while constraining:  ‹∀ 2. (α745''' -> ‹∀ 3. (α747'''' -> α754'''')›)›  <!<  ChurchInt
//│ ╟── while constraining:  α744'  <!<  ChurchInt
//│ ╟── while constraining:  (α743' -> α744')  <!<  (Int -> ChurchInt)
//│ ╟── while constraining:  to_ch_s742'  <!<  (Int -> ChurchInt)
//│ ╟── while constraining:  ‹∀ 0. to_ch_s541'›  <!<  (Int -> ChurchInt)
//│ ╟── while constraining:  ‹∀ 0. ‹∀ 0. to_ch_s541'››  <!<  (Int -> ChurchInt)
//│ ╙── while constraining:  ‹∀ 0. ‹∀ 0. to_ch_s541'››  <!<  ‹∀ 0. (Int -> ChurchInt)›
//│          = [Function: to_ch_s]

rec def to_ch_mix n =
  if n == 0 then zero
  else s (to_ch (n - 1))
//│ to_ch_mix: int -> (((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'N -> 'N & 'b) -> ('c & 'N) -> 'e | ChurchInt)
//│          = [Function: to_ch_mix]

:e // * Needs distrib (see below)
to_church = to_ch_mix
//│ int -> (((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'N -> 'N & 'b) -> ('c & 'N) -> 'e | ChurchInt)
//│   <:  to_church:
//│ int -> ChurchInt
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.284: 	to_church = to_ch_mix
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ╙──      	                        ^^
//│          = [Function: to_ch_mix]


// rec def to_ch n =
//   if n == 0 then zero
//   else succD (to_ch (n - 1))

// rec def to_ch n =
//   succD (to_ch (n - 1))

:e // * Needs to distribute back (in the other direction) here:
rec def to_ch n =
  succD (to_ch n)
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.310: 	rec def to_ch n =
//│ ║         	              ^^^
//│ ║  l.311: 	  succD (to_ch n)
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.26: 	type ChurchInt = forall 'N. ('N -> 'N) -> ('N -> 'N)
//│ ║        	                        ^^
//│ ╟── from quantified type variable:
//│ ║  l.75: 	def succD: forall 'M. ChurchInt -> ('M -> 'M) -> ('M -> 'M)
//│ ╙──      	                  ^^
//│ to_ch: anything -> (anything -> nothing) -> nothing -> anything
//│      = [Function: to_ch1]


// * With distributivity:
:DistributeForalls

succ = s
//│ 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'a
//│     'b <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'a <: 'b -> 'c -> 'e)) -> 'd)))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: s]

succ = s'
//│ ChurchInt -> (forall 'a. 'a -> (forall 'a, 'b, 'c. ('c -> 'd
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'e. ('e
//│   where
//│     'b <: 'a -> 'c -> 'e)) -> 'd)))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: s]

to_church = to_ch_s_mix
//│ int -> (forall 'a. 'a -> (forall 'a, 'b, 'c. (('d & 'c) -> ('d | 'e)
//│   where
//│     'b <: 'a -> 'c -> anything
//│     'a <: (forall 'a, 'b, 'c, 'f. ('f
//│   where
//│     'b <: 'a -> 'c -> 'f)) -> 'e)))
//│   <:  to_church:
//│ int -> ChurchInt
//│          = [Function: to_ch_s_mix]

:e // With distrib, the depth problem becomes a cycle problem...
to_church = to_ch_s
//│ int -> ((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'b & (forall 'a, 'f, 'g, 'h. ('h
//│   where
//│     'a <: 'f -> 'g -> 'h)) -> anything & 'f) -> (forall 'c, 'e. ('e & 'c & 'g) -> 'e)
//│   <:  to_church:
//│ int -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.367: 	to_church = to_ch_s
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (‘N'' -> ‘N'')  <:  α1210''    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (‘N'' -> ‘N'')  <:  α1179'''
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.367: 	to_church = to_ch_s
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  (‘N'' -> ‘N'')  <:  α1219''    FunctionType  TypeVariable
//│ ╙──  ... looks like:  (‘N'' -> ‘N'')  <:  α1179'''
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.367: 	to_church = to_ch_s
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‘N''  <:  α1213''    TraitTag  TypeVariable
//│ ╙──  ... looks like:  ‘N''  <:  α1181''''
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition
//│ ║  l.367: 	to_church = to_ch_s
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‘N''  <:  α1222''    TraitTag  TypeVariable
//│ ╙──  ... looks like:  ‘N''  <:  α1181''''
//│          = [Function: to_ch_s]

to_church = to_ch_mix
//│ int -> (((forall 'a, 'b, 'c, 'd. ('d
//│   where
//│     'a <: 'b -> 'c -> 'd)) -> 'e & 'N -> 'N & 'b) -> ('c & 'N) -> 'e | ChurchInt)
//│   <:  to_church:
//│ int -> ChurchInt
//│          = [Function: to_ch_mix]

rec def to_ch n =
  succD (to_ch n)
//│ to_ch: anything -> (forall 'M. ('M -> 'M) -> 'M -> 'M)
//│      = [Function: to_ch2]


