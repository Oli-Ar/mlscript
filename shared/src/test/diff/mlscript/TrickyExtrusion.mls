
// From SuperType tests

def True = true
//│ True: true
//│     = true

def inc: int -> int
//│ inc: int -> int
//│    = <missing implementation>

test f =
  let r = fun x -> fun g -> (g x, )
  in (r 0 inc, r True not)
//│ test: anything -> ((int,), (bool,),)
//│     = <no result>
//│       inc is not implemented

// * Precise type:
test f = (f 0, f True)
//│ test: (true -> 'a & 0 -> 'b) -> ('b, 'a,)
//│     = [Function: test]

// * Imprecise type (notice the `(0 | true)`):
// * Note: With inferred first-class constraints and generalized curried functions,
// *  this approximation be avoided (see below).
test f =
  let r x = f x
  in (r 0, r True)
//│ test: (nothing -> anything & 0 -> 'a & true -> 'b) -> ('a, 'b,)
//│     = [Function: test1]

// Same example, a little elaborated
test f =
  let r = fun x -> fun g -> (g x, f x)
  in (r 0 inc, r True not)
//│ test: (nothing -> anything & 0 -> 'a & true -> 'b) -> ((int, 'a,), (bool, 'b,),)
//│     = <no result>
//│       inc is not implemented


:GeneralizeCurriedFunctions

:d
test f =
  let r x = f x
  in r 0
//│ 1. Typing term ((f,) => (let r = ((x,) => (f (x,))); (r (0,))))   None
//│ | TYPING POLY LAM
//│ | 2. Typing pattern (f,)   Some(0)
//│ | | 2. Typing pattern f   Some(0)
//│ | | 2. : α104''
//│ | 2. : (α104'',)
//│ | 2. Typing term (let r = ((x,) => (f (x,))); (r (0,)))   Some(0)
//│ | | 3. Typing term ((x,) => (f (x,)))   None
//│ | | | TYPING POLY LAM
//│ | | | 4. Typing pattern (x,)   Some(0)
//│ | | | | 4. Typing pattern x   Some(0)
//│ | | | | 4. : α105''''
//│ | | | 4. : (α105'''',)
//│ | | | 4. Typing term (f (x,))   Some(0)
//│ | | | | 4. Typing term f   Some(0)
//│ | | | | 4. : α104''
//│ | | | | 4. Typing term x   Some(0)
//│ | | | | 4. : α105''''
//│ | | | | CONSTRAIN α104'' <! (α105'''' -> α106'''')
//│ | | | |   where 
//│ | | | | 4. C α104'' <! (α105'''' -> α106'''')
//│ | | | | | NEW α104'' UB (4)
//│ | | | 4. : α106''''
//│ | | 3. : ‹∀ 3. (α105'''' -> α106'''')›
//│ | | 2. Typing term (r (0,))   Some(0)
//│ | | | 2. Typing term r   Some(0)
//│ | | | 2. : ‹∀ 2. ‹∀ 3. (α105'''' -> α106'''')››
//│ | | | 2. Typing term 0   Some(0)
//│ | | | 2. : 0<int,number>
//│ | | | CONSTRAIN ‹∀ 2. ‹∀ 3. (α105'''' -> α106'''')›› <! (0<int,number> -> α107'')
//│ | | |   where 
//│ | | | 2. C ‹∀ 2. ‹∀ 3. (α105'''' -> α106'''')›› <! (0<int,number> -> α107'')
//│ | | | | 2. C ‹∀ 3. (α105'''' -> α106'''')› <! (0<int,number> -> α107'')
//│ | | | | | INST [3]   ‹∀ 3. (α105'''' -> α106'''')›
//│ | | | | |   where  
//│ | | | | | TO [2] ~>  (α105_108'' -> α106_109'')
//│ | | | | |   where  
//│ | | | | | 2. C (α105_108'' -> α106_109'') <! (0<int,number> -> α107'')
//│ | | | | | | 2. C (0<int,number>,) <! (α105_108'',)
//│ | | | | | | | 2. C 0<int,number> <! α105_108''
//│ | | | | | | | | NEW α105_108'' LB (0)
//│ | | | | | | 2. C α106_109'' <! α107''
//│ | | | | | | | NEW α106_109'' UB (2)
//│ | | 2. : α107''
//│ | 2. : α107''
//│ 1. : ‹∀ 1. (α104'' -> α107'')›
//│ ⬤ Typed as: ‹∀ 0. ‹∀ 1. (α104'' -> α107'')››
//│  where: 
//│ 		α104'' <: (α105_108'' -> α106_109'') & (α105_108'' -> α106_109'') & (α105'''' -> α106'''')
//│ 		α105_108'' :> 0<int,number>
//│ 		α106_109'' <: α107''
//│ test: (0 -> 'a & nothing -> anything) -> 'a
//│     = [Function: test2]



test f =
  let r x = f x
  in (r 0, r True)
//│ test: (nothing -> anything & 0 -> 'a & true -> 'b) -> ('a, 'b,)
//│     = [Function: test3]

:d
test id
//│ 0. Typing term (test (id,))   None
//│ | 0. Typing term test   None
//│ | 0. : ‹∀ 0. ‹∀ 1. (α118'' -> (α121'', α124'',))››
//│ | 0. Typing term id   None
//│ | 0. : ‹∀ 0. (α19' -> α19')›
//│ | CONSTRAIN ‹∀ 0. ‹∀ 1. (α118'' -> (α121'', α124'',))›› <! (‹∀ 0. (α19' -> α19')› -> α140)
//│ |   where 
//│ 		α118'' <: ((α119_125'',) -> α120_126'') & ((α119_125'',) -> α120_126'') & ((α119_122'',) -> α120_123'') & ((α119_122'',) -> α120_123'') & ((α119'''',) -> α120'''')
//│ 		α119_122'' :> 0<int,number>
//│ 		α120_123'' <: α121''
//│ 		α119_125'' :> ‹∀ 0. true<bool>›
//│ 		α120_126'' <: α124''
//│ | 0. C ‹∀ 0. ‹∀ 1. (α118'' -> (α121'', α124'',))›› <! (‹∀ 0. (α19' -> α19')› -> α140)
//│ | | 0. C ‹∀ 1. (α118'' -> (α121'', α124'',))› <! (‹∀ 0. (α19' -> α19')› -> α140)
//│ | | | INST [1]   ‹∀ 1. (α118'' -> (α121'', α124'',))›
//│ | | |   where  
//│ 		α118'' <: ((α119_125'',) -> α120_126'') & ((α119_125'',) -> α120_126'') & ((α119_122'',) -> α120_123'') & ((α119_122'',) -> α120_123'') & ((α119'''',) -> α120'''')
//│ 		α119_122'' :> 0<int,number>
//│ 		α120_123'' <: α121''
//│ 		α119_125'' :> ‹∀ 0. true<bool>›
//│ 		α120_126'' <: α124''
//│ | | | TO [0] ~>  (α118_141 -> (α121_147, α124_144,))
//│ | | |   where  
//│ 		α118_141 <: ((α119_142,) -> α120_143) & ((α119_142,) -> α120_143) & ((α119_145,) -> α120_146) & ((α119_145,) -> α120_146) & ((α119_148'''',) -> α120_149'''')
//│ 		α119_142 :> ‹∀ 0. true<bool>›
//│ 		α120_143 <: α124_144
//│ 		α119_145 :> 0<int,number>
//│ 		α120_146 <: α121_147
//│ | | | 0. C (α118_141 -> (α121_147, α124_144,)) <! (‹∀ 0. (α19' -> α19')› -> α140)
//│ | | | | 0. C (‹∀ 0. (α19' -> α19')›,) <! (α118_141,)
//│ | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! α118_141
//│ | | | | | | NEW α118_141 LB (0)
//│ | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | | | INST [0]   ‹∀ 0. (α19' -> α19')›
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | TO [0] ~>  (α19_150 -> α19_150)
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | 0. C (α19_150 -> α19_150) <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | | | | 0. C (α119_142,) <! (α19_150,)
//│ | | | | | | | | | | | | | 0. C (α119_142,) <! (α19_150,)
//│ | | | | | | | | | | | | | | 0. C α119_142 <! α19_150
//│ | | | | | | | | | | | | | | | 0. C α119_142 <! α19_150
//│ | | | | | | | | | | | | | | | | NEW α119_142 UB (0)
//│ | | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α19_150
//│ | | | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α19_150
//│ | | | | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α19_150
//│ | | | | | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α19_150
//│ | | | | | | | | | | | | | | | | | | | | NEW α19_150 LB (0)
//│ | | | | | | | | | | | | 0. C α19_150 <! α120_143
//│ | | | | | | | | | | | | | NEW α19_150 UB (0)
//│ | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α120_143
//│ | | | | | | | | | | | | | | NEW α120_143 LB (0)
//│ | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α124_144
//│ | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α124_144
//│ | | | | | | | | | | | | | | | | 0. C ‹∀ 0. true<bool>› <! α124_144
//│ | | | | | | | | | | | | | | | | | NEW α124_144 LB (0)
//│ | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_142,) -> α120_143)
//│ | | | | | | | | | | | Cached!
//│ | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | | | INST [0]   ‹∀ 0. (α19' -> α19')›
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | TO [0] ~>  (α19_151 -> α19_151)
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | 0. C (α19_151 -> α19_151) <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | | | | 0. C (α119_145,) <! (α19_151,)
//│ | | | | | | | | | | | | | 0. C (α119_145,) <! (α19_151,)
//│ | | | | | | | | | | | | | | 0. C α119_145 <! α19_151
//│ | | | | | | | | | | | | | | | 0. C α119_145 <! α19_151
//│ | | | | | | | | | | | | | | | | NEW α119_145 UB (0)
//│ | | | | | | | | | | | | | | | | 0. C 0<int,number> <! α19_151
//│ | | | | | | | | | | | | | | | | | 0. C 0<int,number> <! α19_151
//│ | | | | | | | | | | | | | | | | | | 0. C 0<int,number> <! α19_151
//│ | | | | | | | | | | | | | | | | | | | NEW α19_151 LB (0)
//│ | | | | | | | | | | | | 0. C α19_151 <! α120_146
//│ | | | | | | | | | | | | | NEW α19_151 UB (0)
//│ | | | | | | | | | | | | | 0. C 0<int,number> <! α120_146
//│ | | | | | | | | | | | | | | NEW α120_146 LB (0)
//│ | | | | | | | | | | | | | | 0. C 0<int,number> <! α121_147
//│ | | | | | | | | | | | | | | | 0. C 0<int,number> <! α121_147
//│ | | | | | | | | | | | | | | | | 0. C 0<int,number> <! α121_147
//│ | | | | | | | | | | | | | | | | | NEW α121_147 LB (0)
//│ | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_145,) -> α120_146)
//│ | | | | | | | | | | | Cached!
//│ | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | | | | 0. C ‹∀ 0. (α19' -> α19')› <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | | | | | INST [0]   ‹∀ 0. (α19' -> α19')›
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | TO [0] ~>  (α19_152 -> α19_152)
//│ | | | | | | | | | | |   where  
//│ | | | | | | | | | | | 0. C (α19_152 -> α19_152) <! ((α119_148'''',) -> α120_149'''')
//│ | | | | | | | | | | | | 0. C (α119_148'''',) <! (α19_152,)
//│ | | | | | | | | | | | | | 0. C (α119_148'''',) <! (α19_152,)
//│ | | | | | | | | | | | | | | 0. C α119_148'''' <! α19_152
//│ | | | | | | | | | | | | | | | 0. C α119_148'''' <! α19_152
//│ | | | | | | | | | | | | | | | | NEW α119_148'''' UB (0)
//│ | | | | | | | | | | | | 0. C α19_152 <! α120_149''''
//│ | | | | | | | | | | | | | NEW α19_152 UB (4)
//│ | | | | 0. C (α121_147, α124_144,) <! α140
//│ | | | | | NEW α140 LB (0)
//│ 0. : α140
//│ ⬤ Typed as: ‹∀ 0. α140›
//│  where: 
//│ 		α140 :> (α121_147, α124_144,)
//│ 		α124_144 :> ‹∀ 0. true<bool>›
//│ 		α121_147 :> 0<int,number>
//│ res: (0, true,)
//│    = [ 0, true ]

// :e
(test id)._1 + 1
not (test id)._2
//│ res: int
//│    = NaN
//│ res: bool
//│    = true

:e
not (test id)._1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.165: 	not (test id)._1
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `bool`
//│ ║  l.104: 	  in (r 0, r True)
//│ ║         	        ^
//│ ╟── but it flows into field selection with expected type `bool`
//│ ║  l.165: 	not (test id)._1
//│ ╙──       	    ^^^^^^^^^^^^
//│ res: bool | error
//│    = true

:e
(test id)._2 + 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.170: 	(test id)._2 + 1
//│ ║         	 ^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `bool`
//│ ║  l.104: 	  in (r 0, r True)
//│ ║         	        ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.165: 	not (test id)._1
//│ ║         	    ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.103: 	  let r x = f x
//│ ╙──       	            ^^^
//│ res: int
//│    = NaN


// * Even works with recursive definition because the constrained type is strictly local to the body!
rec def test f =
  let r x = f x
  in (r 0, r True)
//│ test: (nothing -> anything & 0 -> 'a & true -> 'b) -> ('a, 'b,)
//│     = [Function: test4]


